From 1f2196e434213d0474171532c42d592d42ede593 Mon Sep 17 00:00:00 2001
From: Adarsh Bajpai <abajpai@codeaurora.org>
Date: Mon, 3 Dec 2012 23:08:26 +0530
Subject: [PATCH 74/75] msm: camera:  OV5648 & OV7695 sensor driver support

Kernel driver support for OV7695 and OV5648 camera sensors
for QPR.

Change-Id: I6cdb4063d4d0e4629b5b7204dd1ad8d96d5c4ba0
Signed-off-by: Adarsh Bajpai <abajpai@codeaurora.org>
---
 arch/arm/mach-msm/board-msm7627a-camera.c        |  338 ++++++-
 arch/arm/mach-msm/clock-pcom-lookup.c            |    6 +-
 arch/arm/mach-msm/include/mach/board.h           |    2 +
 drivers/media/video/msm/Kconfig                  |   13 +-
 drivers/media/video/msm/actuators/msm_actuator.c |   28 +-
 drivers/media/video/msm/sensors/Makefile         |    2 +
 drivers/media/video/msm/sensors/msm_sensor.c     |    2 +-
 drivers/media/video/msm/sensors/ov5648_v4l2.c    | 1295 ++++++++++++++++++++++
 drivers/media/video/msm/sensors/ov7695_v4l2.c    |  948 ++++++++++++++++
 include/media/msm_camera.h                       |    3 +
 10 files changed, 2617 insertions(+), 20 deletions(-)
 create mode 100644 drivers/media/video/msm/sensors/ov5648_v4l2.c
 create mode 100644 drivers/media/video/msm/sensors/ov7695_v4l2.c

diff --git a/arch/arm/mach-msm/board-msm7627a-camera.c b/arch/arm/mach-msm/board-msm7627a-camera.c
index 099d630..6ceea6b 100644
--- a/arch/arm/mach-msm/board-msm7627a-camera.c
+++ b/arch/arm/mach-msm/board-msm7627a-camera.c
@@ -30,9 +30,19 @@
 #define GPIO_SKU3_CAM_5MP_SHDN_N   5         /* PWDN */
 #define GPIO_SKU3_CAM_5MP_CAMIF_RESET   6    /* (board_is(EVT))?123:121 RESET */
 #define GPIO_SKU3_CAM_5MP_CAM_DRIVER_PWDN 30
+
+#define GPIO_SKUD_CAM_5MP_SHDN_N   23      /* PWDN */
+#define GPIO_SKUD_CAM_5MP_CAMIF_RESET   79 /* (board_is(EVT))?123:121 RESET */
+#define GPIO_SKUD_CAM_5MP_CAM_VCM_PWDN 16
+#define GPIO_SKUD_CAM_1MP_PWDN 85
+#define GPIO_SKUD_CAM_LED_EN 34
+#define GPIO_SKUD_CAM_LED_FLASH_EN 48
+
 #define GPIO_SKU7_CAM_VGA_SHDN    91
 #define GPIO_SKU7_CAM_5MP_SHDN_N   93         /* PWDN */
 #define GPIO_SKU7_CAM_5MP_CAMIF_RESET   23   /* (board_is(EVT))?123:121 RESET */
+#define GPIO_NOT_CONFIGURED -1
+#define MOUNT_ANGLE_NOT_CONFIGURED -1
 
 #ifdef CONFIG_MSM_CAMERA_V4L2
 static uint32_t camera_off_gpio_table[] = {
@@ -105,6 +115,14 @@ static struct msm_camera_gpio_conf gpio_conf_ov5647 = {
 };
 #endif
 
+#ifdef CONFIG_OV5648
+static struct msm_camera_gpio_conf gpio_conf_ov5648 = {
+	.camera_off_table = camera_off_gpio_table,
+	.camera_on_table = camera_on_gpio_table,
+	.gpio_no_mux = 1,
+};
+#endif
+
 #ifdef CONFIG_MSM_CAMERA_FLASH
 static struct msm_camera_sensor_flash_src msm_flash_src = {
 	.flash_sr_type = MSM_CAMERA_FLASH_SRC_EXT,
@@ -124,6 +142,13 @@ static struct camera_vreg_t ov5647_gpio_vreg[] = {
 	{"cam_ov5647_vdd", REG_GPIO, 0, 0, 0},
 };
 
+#ifdef CONFIG_OV5648
+static struct camera_vreg_t ov5648_gpio_vreg[] = {
+	{"ldo12", REG_LDO, 2700000, 3300000, 0},
+	{"smps3", REG_LDO, 1800000, 1800000, 0},
+};
+#endif
+
 static struct camera_vreg_t ov8825_gpio_vreg[] = {
 	{"cam_ov8825_avdd", REG_GPIO, 0, 0, 0},
 	{"cam_ov8825_vdd", REG_GPIO, 0, 0, 0},
@@ -230,6 +255,56 @@ static struct msm_camera_sensor_info msm_camera_sensor_ov7692_data = {
 };
 #endif
 
+#ifdef CONFIG_OV7695
+/*
+static struct gpio ov7695_cam_req_gpio_skud[] = {
+	{GPIO_SKUD_CAM_1MP_PWDN, GPIOF_DIR_OUT, "CAM_VGA_SHDN"},
+};
+*/ 
+
+static struct msm_gpio_set_tbl ov7695_cam_gpio_set_tbl_skud[] = {
+	{GPIO_SKUD_CAM_1MP_PWDN, GPIOF_OUT_INIT_LOW, 5000},
+	{GPIO_SKUD_CAM_1MP_PWDN, GPIOF_OUT_INIT_HIGH, 5000},
+};
+static struct msm_camera_gpio_conf skud_gpio_conf_ov7695 = {
+//	.cam_gpio_req_tbl = ov7695_cam_req_gpio_skud,
+//	.cam_gpio_req_tbl_size = ARRAY_SIZE(ov7695_cam_req_gpio_skud),
+	.cam_gpio_set_tbl = ov7695_cam_gpio_set_tbl_skud,
+	.cam_gpio_set_tbl_size = ARRAY_SIZE(ov7695_cam_gpio_set_tbl_skud),
+	.camera_off_table = camera_off_gpio_table,
+	.camera_on_table = camera_on_gpio_table,
+	.gpio_no_mux = 1,
+};
+
+static struct camera_vreg_t ov7695_gpio_vreg[] = {
+	{"ldo12", REG_LDO, 2700000, 3300000, 0},
+	{"smps3", REG_LDO, 1800000, 1800000, 0},
+};
+static struct msm_camera_sensor_platform_info sensor_board_info_ov7695 = {
+	.mount_angle = 90,
+	.cam_vreg = msm_cam_vreg,
+	.num_vreg = ARRAY_SIZE(msm_cam_vreg),
+	.gpio_conf = &skud_gpio_conf_ov7695,
+};
+
+static struct msm_camera_sensor_flash_data flash_ov7695 = {
+	.flash_type     = MSM_CAMERA_FLASH_NONE,
+};
+
+static struct msm_camera_sensor_info msm_camera_sensor_ov7695_data = {
+	.sensor_name	    = "ov7695",
+	.sensor_reset_enable    = 0,
+	.sensor_reset	   = GPIO_NOT_CONFIGURED,
+	.sensor_pwd	     = GPIO_NOT_CONFIGURED,
+	.pdata			= &msm_camera_device_data_csi0[0],
+	.flash_data	     = &flash_ov7695,
+	.sensor_platform_info   = &sensor_board_info_ov7695,
+	.csi_if		 = 1,
+	.camera_type = FRONT_CAMERA_2D,
+	.sensor_type = YUV_SENSOR,
+};
+#endif
+
 #ifdef CONFIG_OV5647
 
 static struct msm_actuator_info msm_act_main_cam_5_info = {
@@ -274,6 +349,49 @@ static struct msm_camera_sensor_info msm_camera_sensor_ov5647_data = {
 
 #endif
 
+#ifdef CONFIG_OV5648
+static struct msm_actuator_info msm_act_main_cam_7_info = {
+	.board_info     = &msm_act_main_cam_i2c_info,
+	.cam_name   = MSM_ACTUATOR_MAIN_CAM_7,
+	.bus_id         = MSM_GSBI0_QUP_I2C_BUS_ID,
+	.vcm_pwd        = GPIO_NOT_CONFIGURED,
+	.vcm_enable     = 0,
+};
+
+static struct msm_camera_sensor_platform_info sensor_board_info_ov5648 = {
+	.mount_angle = MOUNT_ANGLE_NOT_CONFIGURED,
+	.cam_vreg = msm_cam_vreg,
+	.num_vreg = ARRAY_SIZE(msm_cam_vreg),
+	.gpio_conf = &gpio_conf_ov5648,
+};
+
+static struct msm_camera_sensor_flash_src msm_flash_src_ov5648 = {
+	.flash_sr_type = MSM_CAMERA_FLASH_SRC_LED1,
+	._fsrc.ext_driver_src.led_en =  GPIO_SKUD_CAM_LED_EN,
+	._fsrc.ext_driver_src.led_flash_en = GPIO_SKUD_CAM_LED_FLASH_EN,
+};
+
+static struct msm_camera_sensor_flash_data flash_ov5648 = {
+	.flash_type             = MSM_CAMERA_FLASH_LED,
+	.flash_src              = &msm_flash_src_ov5648,
+};
+
+static struct msm_camera_sensor_info msm_camera_sensor_ov5648_data = {
+	.sensor_name    = "ov5648",
+	.sensor_reset_enable = 1,
+	.pmic_gpio_enable  = 1,
+	.sensor_reset   = GPIO_NOT_CONFIGURED,
+	.sensor_pwd     = GPIO_NOT_CONFIGURED,
+	.pdata          = &msm_camera_device_data_csi1[0],
+	.flash_data     = &flash_ov5648,
+	.sensor_platform_info   = &sensor_board_info_ov5648,
+	.csi_if                 = 1,
+	.camera_type	= BACK_CAMERA_2D,
+	.sensor_type = BAYER_SENSOR,
+	.actuator_info = &msm_act_main_cam_7_info,
+};
+#endif
+
 static struct msm_camera_gpio_conf gpio_conf_ov8825 = {
 	.camera_off_table = camera_off_gpio_table,
 	.camera_on_table = camera_on_gpio_table,
@@ -300,7 +418,7 @@ static struct msm_camera_sensor_platform_info sensor_board_info_ov8825 = {
 
 static struct msm_actuator_info msm_act_main_cam_3_info = {
 	.board_info     = &msm_act_main_cam_i2c_info,
-	.cam_name   = MSM_ACTUATOR_MAIN_CAM_3,
+	.cam_name       = MSM_ACTUATOR_MAIN_CAM_3,
 	.bus_id         = MSM_GSBI0_QUP_I2C_BUS_ID,
 	.vcm_pwd        = GPIO_SKU3_CAM_5MP_CAM_DRIVER_PWDN,
 	.vcm_enable     = 0,
@@ -380,6 +498,9 @@ static void __init msm7x27a_init_cam(void)
 {
 	if (!(machine_is_msm7x27a_ffa() || machine_is_msm7625a_ffa()
 				|| machine_is_msm7627a_qrd1()
+				|| machine_is_msm8625q_evbd()
+				|| machine_is_msm8625q_skud()
+				|| machine_is_qrd_skud_prime() 
 				|| machine_is_msm8625_ffa())) {
 		sensor_board_info_s5k4e1.cam_vreg = NULL;
 		sensor_board_info_s5k4e1.num_vreg = 0;
@@ -398,10 +519,7 @@ static void __init msm7x27a_init_cam(void)
 	if (machine_is_msm8625_evb() || machine_is_msm7627a_evb()
 				||  machine_is_msm8625_evt()
 				|| machine_is_msm7627a_qrd3()
-				|| machine_is_msm8625_qrd7()
-				|| machine_is_msm8625q_evbd()
-				|| machine_is_msm8625q_skud()
-				|| machine_is_qrd_skud_prime()) {
+				|| machine_is_msm8625_qrd7()) {
 		sensor_board_info_ov7692.cam_vreg =
 			ov7692_gpio_vreg;
 		sensor_board_info_ov7692.num_vreg =
@@ -415,6 +533,30 @@ static void __init msm7x27a_init_cam(void)
 		sensor_board_info_ov8825.num_vreg =
 			ARRAY_SIZE(ov8825_gpio_vreg);
 	}
+	else if(machine_is_msm8625q_evbd()||
+		machine_is_msm8625q_skud()||
+		machine_is_qrd_skud_prime())
+	{  //for SKUD
+#ifdef CONFIG_OV5648
+		sensor_board_info_ov5648.cam_vreg = ov5648_gpio_vreg;
+		sensor_board_info_ov5648.num_vreg = ARRAY_SIZE(ov5648_gpio_vreg);
+		msm_act_main_cam_7_info.vcm_pwd = GPIO_SKUD_CAM_5MP_CAM_VCM_PWDN;
+		msm_act_main_cam_7_info.vcm_enable = 1;
+		msm_camera_sensor_ov5648_data.sensor_reset=GPIO_SKUD_CAM_5MP_CAMIF_RESET;
+		msm_camera_sensor_ov5648_data.sensor_pwd = GPIO_SKUD_CAM_5MP_SHDN_N;
+		sensor_board_info_ov5648.mount_angle = 90;
+		msm_flash_src_ov5648._fsrc.ext_driver_src.led_en = GPIO_SKUD_CAM_LED_EN;
+		msm_flash_src_ov5648._fsrc.ext_driver_src.led_flash_en = GPIO_SKUD_CAM_LED_FLASH_EN;
+#endif
+#ifdef CONFIG_OV7695
+		sensor_board_info_ov7695.cam_vreg = ov7695_gpio_vreg;
+		sensor_board_info_ov7695.num_vreg = ARRAY_SIZE(ov7695_gpio_vreg);
+		msm_camera_sensor_ov7695_data.vcm_pwd = 0;
+		msm_camera_sensor_ov7695_data.vcm_enable = 0;
+		sensor_board_info_ov7695.gpio_conf = &skud_gpio_conf_ov7695;
+		sensor_board_info_ov7695.mount_angle = 270;
+#endif
+	}
 	platform_device_register(&msm_camera_server);
 	if (machine_is_msm8625_surf() || machine_is_msm8625_evb()
 			|| machine_is_msm8625_evt()
@@ -457,7 +599,7 @@ static struct i2c_board_info i2c_camera_devices[] = {
 		.platform_data = &msm_camera_sensor_ov7692_data,
 	},
 	{
-		I2C_BOARD_INFO("ov5647", 0x36 << 1),
+		I2C_BOARD_INFO("ov5647", 0x34 << 1),
 		.platform_data = &msm_camera_sensor_ov5647_data,
 	},
 	{
@@ -467,7 +609,24 @@ static struct i2c_board_info i2c_camera_devices[] = {
 	{
 		I2C_BOARD_INFO("sc628a", 0x6E),
 	},
+
+};
+
+static struct i2c_board_info i2c_camera_devices_qpr[] = {
+#ifdef CONFIG_OV5648
+	{
+		I2C_BOARD_INFO("ov5648", 0x36 << 1),//original
+		.platform_data = &msm_camera_sensor_ov5648_data,
+	},
+#endif
+#ifdef CONFIG_OV7695
+	{
+		I2C_BOARD_INFO("ov7695", 0x21 << 1),
+		.platform_data = &msm_camera_sensor_ov7695_data,
+	},
+#endif
 };
+
 #else
 static uint32_t camera_off_gpio_table[] = {
 	GPIO_CFG(15, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
@@ -615,6 +774,121 @@ static void evb_camera_gpio_cfg(void)
 
 }
 
+
+static void evbd_camera_gpio_cfg(void)
+{
+	int rc = 0;
+
+	rc = gpio_request(GPIO_SKU3_CAM_5MP_SHDN_N, "ov5647");
+	if (rc < 0)
+		pr_err("%s: gpio_request OV5647 sensor_pwd: %d failed!",
+			 __func__, GPIO_SKU3_CAM_5MP_SHDN_N);
+
+	rc = gpio_tlmm_config(GPIO_CFG(GPIO_SKU3_CAM_5MP_SHDN_N,
+				0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN,
+				GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+	if (rc < 0) {
+		pr_err("%s:unable to enable Powr Dwn gpio for main camera!\n",
+			 __func__);
+		gpio_free(GPIO_SKU3_CAM_5MP_SHDN_N);
+	}
+
+	rc = gpio_direction_output(GPIO_SKU3_CAM_5MP_SHDN_N, 1);
+	if (rc < 0)
+		pr_err("%s: unable to set gpio: %d direction for ov5647 camera\n",
+			__func__,GPIO_SKU3_CAM_5MP_SHDN_N);
+
+	rc = gpio_request(GPIO_SKU3_CAM_5MP_CAMIF_RESET, "ov5647");
+	if (rc < 0)
+		pr_err("%s: gpio_request OV5647 sensor_reset: %d failed!",
+			 __func__, GPIO_SKU3_CAM_5MP_CAMIF_RESET);
+
+	rc = gpio_tlmm_config(GPIO_CFG(
+				GPIO_SKU3_CAM_5MP_CAMIF_RESET,
+				0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN,
+				GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+	if (rc < 0) {
+		pr_err("%s: unable to enable reset gpio for main camera!\n",
+			 __func__);
+		gpio_free(GPIO_SKU3_CAM_5MP_CAMIF_RESET);
+	}
+
+	rc = gpio_direction_output(
+			GPIO_SKU3_CAM_5MP_CAMIF_RESET, 1);
+	if (rc < 0)
+		pr_err("%s: unable to set gpio: %d direction for ov5647 camera\n",
+			__func__, GPIO_SKU3_CAM_5MP_CAMIF_RESET);
+}
+
+
+static void skud_camera_gpio_cfg(void)
+{
+	int rc = 0;
+	printk("skuD_camera_gpio_cfg in, cfg gpio\n");
+	printk("gpio request: GPIO_SKUD_CAM_5MP_SHDN_N is %d\n", GPIO_SKUD_CAM_5MP_SHDN_N);
+	rc = gpio_request(GPIO_SKUD_CAM_5MP_SHDN_N, "ov5648");
+	if (rc < 0)
+		printk("%s: gpio_request OV5648 sensor_pwd: %d failed!",
+			 __func__, GPIO_SKUD_CAM_5MP_SHDN_N);
+
+	rc = gpio_tlmm_config(GPIO_CFG(GPIO_SKUD_CAM_5MP_SHDN_N,
+				0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN,
+				GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+	if (rc < 0) {
+		printk("%s:unable to enable Powr Dwn gpio for main camera!\n",
+			 __func__);
+		gpio_free(GPIO_SKUD_CAM_5MP_SHDN_N);
+	}
+
+	rc = gpio_direction_output(GPIO_SKUD_CAM_5MP_SHDN_N, 1);
+	if (rc < 0)
+		pr_err("%s: unable to set gpio: %d direction for ov5648 camera\n",
+			__func__, GPIO_SKUD_CAM_5MP_SHDN_N);
+
+	printk("gpio request: GPIO_SKUD_CAM_5MP_CAMIF_RESET is %d\n", GPIO_SKUD_CAM_5MP_CAMIF_RESET);
+	rc = gpio_request(GPIO_SKUD_CAM_5MP_CAMIF_RESET, "ov5648");
+	if (rc < 0)
+		pr_err("%s: gpio_request OV5648 sensor_reset: %d failed!",
+			 __func__, GPIO_SKUD_CAM_5MP_CAMIF_RESET);
+
+	rc = gpio_tlmm_config(GPIO_CFG(
+				GPIO_SKUD_CAM_5MP_CAMIF_RESET,
+				0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN,
+				GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+	if (rc < 0) {
+		pr_err("%s: unable to enable reset gpio for main camera!\n",
+			 __func__);
+		gpio_free(GPIO_SKUD_CAM_5MP_CAMIF_RESET);
+	}
+
+	rc = gpio_direction_output(
+			GPIO_SKUD_CAM_5MP_CAMIF_RESET, 1);
+	if (rc < 0)
+		pr_err("%s: unable to set gpio: %d direction for ov5648 camera\n",
+			__func__, GPIO_SKUD_CAM_5MP_CAMIF_RESET);
+
+	printk("gpio request: GPIO_SKUD_CAM_1MP_PWDN is %d\n", GPIO_SKUD_CAM_1MP_PWDN);
+		rc = gpio_request(GPIO_SKUD_CAM_1MP_PWDN, "OV7695");
+	if (rc < 0)
+	pr_err("%s: gpio_request OV7695 sensor_pwdn: %d failed!",
+		__func__, GPIO_SKUD_CAM_1MP_PWDN);
+
+	rc = gpio_tlmm_config(GPIO_CFG(
+		GPIO_SKUD_CAM_1MP_PWDN,
+		0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN,
+		GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+	if (rc < 0) {
+		pr_err("%s: unable to enable reset gpio for front camera!\n", __func__);
+		gpio_free(GPIO_SKUD_CAM_1MP_PWDN);
+	}
+
+	rc = gpio_direction_output(GPIO_SKUD_CAM_1MP_PWDN, 0);
+	if (rc < 0)
+		pr_err("%s: unable to set gpio: %d direction for ov7695 camera\n",
+		__func__, GPIO_SKUD_CAM_1MP_PWDN);
+
+}
+
 #ifndef CONFIG_MSM_CAMERA_V4L2
 
 static void msm_camera_vreg_config(int vreg_en)
@@ -1093,8 +1367,8 @@ static void __init register_i2c_devices(void)
 }
 
 #ifndef CONFIG_MSM_CAMERA_V4L2
-#define LCD_CAMERA_LDO_2V8 129 /* SKU1&SKU3 2.8V LDO */
-#define SKU3_LCD_CAMERA_LDO_1V8 130 /* SKU3 1.8V LDO */
+#define LCD_CAMERA_LDO_2V8 35 /* SKU1&SKU3 2.8V LDO */
+#define SKU3_LCD_CAMERA_LDO_1V8 40 /* SKU3 1.8V LDO */
 #define SKU7_LCD_CAMERA_LDO_1V8 58 /* SKU7 1.8V LDO */
 
 static int lcd_camera_ldo_1v8 = SKU3_LCD_CAMERA_LDO_1V8;
@@ -1192,6 +1466,30 @@ int lcd_camera_power_onoff(int on)
 }
 EXPORT_SYMBOL(lcd_camera_power_onoff);
 #endif
+void camera_af_software_powerdown(struct i2c_client *client)
+{
+	int rc = 0;
+	unsigned char txdata[] = {0x80, 0x0};
+	struct i2c_msg msg[] = {
+		{
+			.addr = 0x18>>1,
+			.flags = 0,
+			.len = 2,
+			.buf = txdata,
+		 },
+	};
+	printk("camera_af_software_powerdown IN...\n");
+	/* send software powerdown cmd to AF motor, avoid current leak */
+	if (machine_is_msm8625q_evbd()||
+	machine_is_msm8625q_skud() ){
+		printk("SKUA AF Motor software powerdown, write i2c saddr:0x18, waddr:0x80, wdata:0x00\n");
+		rc = i2c_transfer(client->adapter, msg, 1);
+		if (rc < 0)
+			printk("AF software powerdown faild\n");
+		return;
+	}
+}
+EXPORT_SYMBOL(camera_af_software_powerdown);
 
 void __init msm7627a_camera_init(void)
 {
@@ -1217,15 +1515,21 @@ void __init msm7627a_camera_init(void)
 	if (machine_is_msm7627a_evb() || machine_is_msm8625_evb()
 			|| machine_is_msm8625_evt()
 			|| machine_is_msm7627a_qrd3()
-			|| machine_is_msm8625_qrd7()
-			|| machine_is_msm8625q_evbd()
-			|| machine_is_msm8625q_skud()
-			|| machine_is_qrd_skud_prime()) {
+			|| machine_is_msm8625_qrd7()) {
 #ifndef CONFIG_MSM_CAMERA_V4L2
 		lcd_camera_power_init();
 #endif
 		evb_camera_gpio_cfg();
-	}
+	} 
+	if(machine_is_msm8625q_evbd())
+		evbd_camera_gpio_cfg();
+
+	if(machine_is_qrd_skud_prime() ||
+		machine_is_msm8625q_skud()||
+		machine_is_msm8625q_evbd())
+	{
+		skud_camera_gpio_cfg();
+ 	}
 
 #ifndef CONFIG_MSM_CAMERA_V4L2
 	if (machine_is_msm7627a_qrd1()) {
@@ -1296,7 +1600,15 @@ void __init msm7627a_camera_init(void)
 	} else
 #endif
 		pr_debug("i2c_register_board_info\n");
+        if (machine_is_qrd_skud_prime()||
+			machine_is_msm8625q_skud()||
+			machine_is_msm8625q_evbd()) {
+		i2c_register_board_info(MSM_GSBI0_QUP_I2C_BUS_ID,
+				i2c_camera_devices_qpr,
+				ARRAY_SIZE(i2c_camera_devices_qpr));
+	} else {
 		i2c_register_board_info(MSM_GSBI0_QUP_I2C_BUS_ID,
 				i2c_camera_devices,
 				ARRAY_SIZE(i2c_camera_devices));
+	}
 }
diff --git a/arch/arm/mach-msm/clock-pcom-lookup.c b/arch/arm/mach-msm/clock-pcom-lookup.c
index 2a2cc01..61fa9a2 100644
--- a/arch/arm/mach-msm/clock-pcom-lookup.c
+++ b/arch/arm/mach-msm/clock-pcom-lookup.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -322,12 +322,16 @@ static struct clk_lookup msm_cmn_clk_7625a_7627a[] __initdata = {
 	CLK_LOOKUP("cam_clk",		cam_m_clk.c,	"0-0078"),
 	CLK_LOOKUP("cam_clk",		cam_m_clk.c,	"0-006c"),
 	CLK_LOOKUP("cam_clk",		cam_m_clk.c,	"0-000d"),
+	CLK_LOOKUP("cam_clk",		cam_m_clk.c,	"0-0042"),
 	CLK_LOOKUP("csi_clk",		csi0_clk.c,	"msm_camera_ov9726.0"),
 	CLK_LOOKUP("csi_pclk",		csi0_p_clk.c,	"msm_camera_ov9726.0"),
 	CLK_LOOKUP("csi_vfe_clk",	csi0_vfe_clk.c,	"msm_camera_ov9726.0"),
 	CLK_LOOKUP("csi_clk",		csi0_clk.c,	"msm_camera_ov7692.0"),
 	CLK_LOOKUP("csi_pclk",		csi0_p_clk.c,	"msm_camera_ov7692.0"),
 	CLK_LOOKUP("csi_vfe_clk",	csi0_vfe_clk.c,	"msm_camera_ov7692.0"),
+	CLK_LOOKUP("csi_clk",		csi0_clk.c,	"msm_camera_ov7695.0"),
+	CLK_LOOKUP("csi_pclk",		csi0_p_clk.c,	"msm_camera_ov7695.0"),
+	CLK_LOOKUP("csi_vfe_clk",	csi0_vfe_clk.c,	"msm_camera_ov7695.0"),
 	CLK_LOOKUP("csi_clk",		csi1_clk.c,	NULL),
 	CLK_LOOKUP("csi_pclk",		csi1_p_clk.c,	NULL),
 	CLK_LOOKUP("csi_vfe_clk",	csi1_vfe_clk.c,	NULL),
diff --git a/arch/arm/mach-msm/include/mach/board.h b/arch/arm/mach-msm/include/mach/board.h
index 2106d7b..7a54c6d 100644
--- a/arch/arm/mach-msm/include/mach/board.h
+++ b/arch/arm/mach-msm/include/mach/board.h
@@ -251,6 +251,8 @@ enum msm_camera_actuator_name {
 	MSM_ACTUATOR_MAIN_CAM_3,
 	MSM_ACTUATOR_MAIN_CAM_4,
 	MSM_ACTUATOR_MAIN_CAM_5,
+	MSM_ACTUATOR_MAIN_CAM_6,
+	MSM_ACTUATOR_MAIN_CAM_7,
 	MSM_ACTUATOR_WEB_CAM_0,
 	MSM_ACTUATOR_WEB_CAM_1,
 	MSM_ACTUATOR_WEB_CAM_2,
diff --git a/drivers/media/video/msm/Kconfig b/drivers/media/video/msm/Kconfig
index 5d3a948..b632ad6 100644
--- a/drivers/media/video/msm/Kconfig
+++ b/drivers/media/video/msm/Kconfig
@@ -42,13 +42,16 @@ config OV5640
 	default n
 	---help---
 	Omni 5M YUV Sensor
-
 config OV5647
 	bool "Sensor ov5647 (BAYER 5M)"
 	depends on MSM_CAMERA
 	---help---
 	  OV 5M Bayer Sensor with AutoFocus
-
+config OV5648
+	bool "Sensor ov5648 (BAYER 5M)"
+	depends on MSM_CAMERA
+	---help---
+	  OV 5M Bayer Sensor with AutoFocus
 config AD5046_ACT
 	bool "Lens actuator ad5046"
 	depends on MSM_CAMERA && OV5647
@@ -295,3 +298,9 @@ config OV7692
 	depends on MSM_CAMERA
 	---help---
 	  Omni Vision VGA YUV Sensor
+config OV7695
+	bool "Sensor OV7695 (VGA YUV)"
+	depends on MSM_CAMERA && MSM_CAMERA_V4L2
+	default y
+	---help---
+	  Omni Vision VGA YUV Sensor for QRD Devices
diff --git a/drivers/media/video/msm/actuators/msm_actuator.c b/drivers/media/video/msm/actuators/msm_actuator.c
index 50399de..c602f63 100644
--- a/drivers/media/video/msm/actuators/msm_actuator.c
+++ b/drivers/media/video/msm/actuators/msm_actuator.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -67,9 +67,11 @@ int32_t msm_actuator_i2c_write(struct msm_actuator_ctrl_t *a_ctrl,
 	struct msm_actuator_reg_params_t *write_arr = a_ctrl->reg_tbl;
 	uint32_t hw_dword = hw_params;
 	uint16_t i2c_byte1 = 0, i2c_byte2 = 0;
-	uint16_t value = 0;
+	uint32_t value = 0;
 	uint32_t size = a_ctrl->reg_tbl_size, i = 0;
 	int32_t rc = 0;
+	unsigned char buf[4];
+	int length = 0;
 	CDBG("%s: IN\n", __func__);
 	for (i = 0; i < size; i++) {
 		if (write_arr[i].reg_write_type == MSM_ACTUATOR_WRITE_DAC) {
@@ -103,7 +105,27 @@ int32_t msm_actuator_i2c_write(struct msm_actuator_ctrl_t *a_ctrl,
 				i2c_byte1 = (value & 0xFF00) >> 8;
 				i2c_byte2 = value & 0xFF;
 			}
-		} else {
+		}
+		else if (write_arr[i].reg_write_type == MSM_ACTUATOR_WRITE_DAC_AD5823) {
+			value = (next_lens_position <<
+				write_arr[i].data_shift) |
+				((hw_dword & write_arr[i].hw_mask) <<
+				write_arr[i].hw_shift);
+
+			buf[0] = write_arr[i].reg_addr;
+			buf[1] = (value & 0xff00)>>8;//MSB
+			buf[2] = value & 0xff;//LSB
+			length = 3;
+			CDBG("%s: position is 0x%x, MSB0x%x, LSB:0x%x\r\n", __func__, value, buf[1], buf[2]);
+			rc = msm_camera_i2c_txdata(&a_ctrl->i2c_client, buf, length);
+			if (rc < 0) {
+				pr_err("%s: i2c write error:%d\n",
+					__func__, rc);
+				return rc;
+			}
+			break;
+		}
+		else {
 			i2c_byte1 = write_arr[i].reg_addr;
 			i2c_byte2 = (hw_dword & write_arr[i].hw_mask) >>
 				write_arr[i].hw_shift;
diff --git a/drivers/media/video/msm/sensors/Makefile b/drivers/media/video/msm/sensors/Makefile
index 5f3f6dd..ed2c949 100644
--- a/drivers/media/video/msm/sensors/Makefile
+++ b/drivers/media/video/msm/sensors/Makefile
@@ -14,5 +14,7 @@ obj-$(CONFIG_MT9M114) += mt9m114_v4l2.o
 obj-$(CONFIG_S5K4E1) += s5k4e1_v4l2.o
 obj-$(CONFIG_MT9E013) += mt9e013_v4l2.o
 obj-$(CONFIG_WEBCAM_OV9726) += ov9726_v4l2.o
+obj-$(CONFIG_OV5648) += ov5648_v4l2.o
 obj-$(CONFIG_OV7692) += ov7692_v4l2.o
+obj-$(CONFIG_OV7695) += ov7695_v4l2.o
 obj-$(CONFIG_VX6953) += vx6953.o
diff --git a/drivers/media/video/msm/sensors/msm_sensor.c b/drivers/media/video/msm/sensors/msm_sensor.c
index 8ab3963..c1a6d39 100644
--- a/drivers/media/video/msm/sensors/msm_sensor.c
+++ b/drivers/media/video/msm/sensors/msm_sensor.c
@@ -691,7 +691,7 @@ int32_t msm_sensor_match_id(struct msm_sensor_ctrl_t *s_ctrl)
 		return rc;
 	}
 
-	CDBG("msm_sensor id: %d\n", chipid);
+	CDBG("msm_sensor id: 0x%x\n", chipid);
 	if (chipid != s_ctrl->sensor_id_info->sensor_id) {
 		pr_err("msm_sensor_match_id chip id doesnot match\n");
 		return -ENODEV;
diff --git a/drivers/media/video/msm/sensors/ov5648_v4l2.c b/drivers/media/video/msm/sensors/ov5648_v4l2.c
new file mode 100644
index 0000000..d571662
--- /dev/null
+++ b/drivers/media/video/msm/sensors/ov5648_v4l2.c
@@ -0,0 +1,1295 @@
+/* Copyright (c) 2012, The Linux Foundation. All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+
+#include "msm_sensor.h"
+#include "msm.h"
+#define SENSOR_NAME "ov5648"
+#define PLATFORM_DRIVER_NAME "msm_camera_ov5648"
+#define ov5648_obj ov5648_##obj
+
+#ifdef CDBG
+#undef CDBG
+#endif
+#ifdef CDBG_HIGH
+#undef CDBG_HIGH
+#endif
+
+#define OV5648_VERBOSE_DGB
+
+#ifdef OV5648_VERBOSE_DGB
+#define CDBG(fmt, args...) printk(fmt, ##args)
+#define CDBG_HIGH(fmt, args...) printk(fmt, ##args)
+#else
+#define CDBG(fmt, args...) do { } while (0)
+#define CDBG_HIGH(fmt, args...) printk(fmt, ##args)
+#endif
+
+#define OV5648_OTP_FEATURE
+//#ifdef OV5648_OTP_FEATURE
+//#undef OV5648_OTP_FEATURE
+//#endif
+
+static struct msm_sensor_ctrl_t ov5648_s_ctrl;
+
+DEFINE_MUTEX(ov5648_mut);
+
+static struct msm_camera_i2c_reg_conf ov5648_start_settings[] = {
+	{0x4202, 0x00},  /* streaming on */
+};
+
+static struct msm_camera_i2c_reg_conf ov5648_stop_settings[] = {
+	{0x4202, 0x0f},  /* streaming off*/
+};
+
+static struct msm_camera_i2c_reg_conf ov5648_groupon_settings[] = {
+	{0x3208, 0x0},
+};
+
+static struct msm_camera_i2c_reg_conf ov5648_groupoff_settings[] = {
+	{0x3208, 0x10},
+	{0x3208, 0xa0},
+};
+
+static struct msm_camera_i2c_reg_conf ov5648_prev_settings[] = {
+	/*1296*972 preview*/
+	// 1296x972 30fps 2 lane MIPI 420Mbps/lane
+	{0x3035, 0x21}, //PLL
+	{0x3501, 0x3d},//exposure
+	{0x3502, 0x00},//exposure
+	{0x3708, 0x66},
+	{0x3709, 0x52},
+	{0x370c, 0xc3},
+
+	{0x3800, 0x00},//xstart = 0
+	{0x3801, 0x00},//x start
+	{0x3802, 0x00},//y start = 0
+	{0x3803, 0x00},//y start
+	{0x3804, 0x0a},//xend = 2623
+	{0x3805, 0x3f},//xend
+	{0x3806, 0x07},//yend = 1955
+	{0x3807, 0xa3},//yend
+	{0x3808, 0x05},//x output size = 1296
+	{0x3809, 0x10},//x output size
+	{0x380a, 0x03},//y output size = 972
+	{0x380b, 0xcc},//y output size
+	{0x380c, 0x0B},//hts = 2816
+	{0x380d, 0x00},//hts
+	{0x380e, 0x03},//vts = 992
+	{0x380f, 0xe0},//vts
+	{0x3810, 0x00},//isp x win = 8
+	{0x3811, 0x08},//isp x win
+	{0x3812, 0x00},//isp y win = 4
+	{0x3813, 0x04},//isp y win
+	{0x3814, 0x31},//x inc
+	{0x3815, 0x31},//y inc
+	{0x3817, 0x00},//hsync start
+	{0x3820, 0x08},//flip off, v bin off
+	{0x3821, 0x07},//mirror on, h bin on
+
+	{0x4004, 0x02},//black line number
+	{0x4005, 0x18},//BLC normal freeze
+	{0x350b, 0x80},//gain = 8x
+	{0x4837, 0x17},//MIPI global timing
+};
+
+static struct msm_camera_i2c_reg_conf ov5648_snap_settings[] = {
+	/* 2592*1944 capture */
+	//2592x1944 15fps 2 lane MIPI 420Mbps/lane
+	{0x3035, 0x21}, //PLL
+	{0x3501, 0x7b}, //exposure
+	{0x2502, 0x00}, //exposure
+	{0x3708, 0x63}, //
+	{0x3709, 0x12}, //
+	{0x370c, 0xc0}, //
+
+	{0x3800, 0x00}, //xstart = 0
+	{0x3801, 0x00}, //xstart
+	{0x3802, 0x00}, //ystart = 0
+	{0x3803, 0x00}, //ystart
+	{0x3804, 0x0a}, //xend = 2623
+	{0x3805, 0x3f}, //xend
+	{0x3806, 0x07}, //yend = 1955
+	{0x3807, 0xa3}, //yend
+	{0x3808, 0x0a}, //x output size = 2592
+	{0x3809, 0x20}, //x output size
+	{0x380a, 0x07}, //y output size = 1944
+	{0x380b, 0x98}, //y output size
+	{0x380c, 0x0b}, //hts = 2816
+	{0x380d, 0x00}, //hts
+	{0x380e, 0x07}, //vts = 1984
+	{0x380f, 0xc0}, //vts
+	{0x3810, 0x00}, //isp x win = 16
+	{0x3811, 0x10}, //isp x win
+	{0x3812, 0x00}, //isp y win = 6
+	{0x3813, 0x06}, //isp y win
+	{0x3814, 0x11}, //x inc
+	{0x3815, 0x11}, //y inc
+	{0x3817, 0x00}, //hsync start
+	{0x3820, 0x40}, //flip off, v bin off
+	{0x3821, 0x06}, //mirror on, v bin off
+
+	{0x4004, 0x04}, //black line number
+	{0x4005, 0x1a}, //BLC always update
+	{0x350b, 0x40}, //gain = 4x
+	{0x4837, 0x17}, //MIPI global timing
+};
+
+static struct msm_camera_i2c_reg_conf ov5648_video_60fps_settings[] = {
+	//640x480 60fps 2 lane MIPI 280Mbps/lane
+	{0x3035, 0x31}, //PLL
+	{0x2501, 0x1e}, //exposure
+	{0x3502, 0xc0}, //exposure
+	{0x3708, 0x69},
+	{0x3709, 0x92},
+	{0x370c, 0xc3},
+
+	{0x3800, 0x00}, //xstart = 0
+	{0x3801, 0x00}, //xstart
+	{0x3802, 0x00}, //ystart = 2
+	{0x3803, 0x02}, //ystart
+	{0x3804, 0x0a}, //xend = 2623
+	{0x3805, 0x3f}, //xend
+	{0x3806, 0x07}, //yend = 1953
+	{0x3807, 0xa1}, //yend
+	{0x3808, 0x02}, //x output size = 640
+	{0x3809, 0x80}, //x output size
+	{0x380a, 0x01}, //y output size = 480
+	{0x380b, 0xe0}, //y output size
+	{0x380c, 0x07}, //hts = 1832
+	{0x380d, 0x28}, //hts
+	{0x380e, 0x01}, //vts = 508
+	{0x380f, 0xfc}, //vts
+	{0x3810, 0x00}, //isp x win = 8
+	{0x3811, 0x08}, //isp x win
+	{0x3812, 0x00}, //isp y win = 4
+	{0x3813, 0x04}, //isp y win
+	{0x3814, 0x71}, //x inc
+	{0x3815, 0x53}, //y inc
+	{0x3817, 0x00}, //hsync start
+	{0x3820, 0x08}, //flip off, v bin off
+	{0x3821, 0x07}, //mirror on, h bin on
+
+	{0x4004, 0x02}, //number of black line
+	{0x4005, 0x18}, //BLC normal freeze
+	{0x350b, 0xf0}, //gain = 8x
+	{0x4837, 0x23}, //MIPI global timing
+};
+
+static struct msm_camera_i2c_reg_conf ov5648_video_90fps_settings[] = {
+	// 640x480 90fps 2 lane MIPI 420Mbps/lane
+	{0x3035, 0x21}, //PLL
+	{0x2501, 0x1e}, //exposure
+	{0x3502, 0xc0}, //exposure
+	{0x3708, 0x69},
+	{0x3709, 0x92},
+	{0x370c, 0xc3},
+
+	{0x3800, 0x00}, //xstart = 0
+	{0x3801, 0x00}, //xstart
+	{0x3802, 0x00}, //ystart = 2
+	{0x3803, 0x02}, //ystart
+	{0x3804, 0x0a}, //xend = 2623
+	{0x3805, 0x3f}, //xend
+	{0x3806, 0x07}, //yend = 1953
+	{0x3807, 0xa1}, //yend
+	{0x3808, 0x02}, //x output size = 640
+	{0x3809, 0x80}, //x output size
+	{0x380a, 0x01}, //y output size = 480
+	{0x380b, 0xe0}, //y output size
+	{0x380c, 0x07}, //hts = 1832
+	{0x380d, 0x28}, //hts
+	{0x380e, 0x01}, //vts = 508
+	{0x380f, 0xfc}, //vts
+	{0x3810, 0x00}, //isp x win = 8
+	{0x3811, 0x08}, //isp x win
+	{0x3812, 0x00}, //isp y win = 4
+	{0x3813, 0x04}, //isp y win
+	{0x3814, 0x71}, //x inc
+	{0x3815, 0x53}, //y inc
+	{0x3817, 0x00}, //hsync start
+	{0x3820, 0x08}, //flip off, v bin off
+	{0x3821, 0x07}, //mirror on, h bin on
+
+	{0x4004, 0x02}, //number of black line
+	{0x4005, 0x18}, //BLC normal freeze
+	{0x350b, 0xf0}, //gain = 8x
+	{0x4837, 0x17}, //MIPI global timing
+};
+
+static struct msm_camera_i2c_reg_conf ov5648_zsl_settings[] = {
+	{0x3035, 0x21}, //PLL
+	{0x3501, 0x7b}, //exposure
+	{0x2502, 0x00}, //exposure
+	{0x3708, 0x63}, //
+	{0x3709, 0x12}, //
+	{0x370c, 0xc0}, //
+
+	{0x3800, 0x00}, //xstart = 0
+	{0x3801, 0x00}, //xstart
+	{0x3802, 0x00}, //ystart = 0
+	{0x3803, 0x00}, //ystart
+	{0x3804, 0x0a}, //xend = 2623
+	{0x3805, 0x3f}, //xend
+	{0x3806, 0x07}, //yend = 1955
+	{0x3807, 0xa3}, //yend
+	{0x3808, 0x0a}, //x output size = 2592
+	{0x3809, 0x20}, //x output size
+	{0x380a, 0x07}, //y output size = 1944
+	{0x380b, 0x98}, //y output size
+	{0x380c, 0x0b}, //hts = 2816
+	{0x380d, 0x00}, //hts
+	{0x380e, 0x07}, //vts = 1984
+	{0x380f, 0xc0}, //vts
+	{0x3810, 0x00}, //isp x win = 16
+	{0x3811, 0x10}, //isp x win
+	{0x3812, 0x00}, //isp y win = 6
+	{0x3813, 0x06}, //isp y win
+	{0x3814, 0x11}, //x inc
+	{0x3815, 0x11}, //y inc
+	{0x3817, 0x00}, //hsync start
+	{0x3820, 0x40}, //flip off, v bin off
+	{0x3821, 0x06}, //mirror on, v bin off
+
+	{0x4004, 0x04}, //black line number
+	{0x4005, 0x1a}, //BLC always update
+	{0x350b, 0x40}, //gain = 4x
+	{0x4837, 0x17}, //MIPI global timing
+};
+
+static struct msm_camera_i2c_reg_conf ov5648_recommend_settings[] =
+{
+//	{0x0103, 0x01}, // software reset
+	{0x3001, 0x00}, // D[7:0] set to input
+	{0x3002, 0x00}, // Vsync, PCLK, FREX, Strobe, CSD, CSK, GPIO input
+	{0x3011, 0x02}, // Drive strength 2x
+	{0x3018, 0x4c}, // MIPI 2 lane
+	{0x3022, 0x00},
+	{0x3034, 0x1a}, // 10-bit mode
+	{0x3035, 0x21}, // PLL
+	{0x3036, 0x69}, // PLL
+	{0x3037, 0x03}, // PLL
+	{0x3038, 0x00}, // PLL
+	{0x3039, 0x00}, // PLL
+	{0x303a, 0x00}, // PLLS
+	{0x303b, 0x19}, // PLLS
+	{0x303c, 0x11}, // PLLS
+	{0x303d, 0x30}, //  PLLS
+	{0x3105, 0x11},
+	{0x3106, 0x05}, // PLL
+	{0x3304, 0x28},
+	{0x3305, 0x41},
+	{0x3306, 0x30},
+	{0x3308, 0x00},
+	{0x3309, 0xc8},
+	{0x330a, 0x01},
+	{0x330b, 0x90},
+	{0x330c, 0x02},
+	{0x330d, 0x58},
+	{0x330e, 0x03},
+	{0x330f, 0x20},
+	{0x3300, 0x00},
+
+	{0x3500, 0x00}, // exposure [19:16]
+	{0x3501, 0x3d}, // exposure [15:8]
+	{0x3502, 0x00}, // exposure [7:0], exposure = 0x3d0 = 976
+	{0x3503, 0x07}, // gain has no delay, manual agc/aec
+	{0x350a, 0x00}, // gain[9:8]
+	{0x350b, 0x40}, // gain[7:0], gain = 4x
+
+	{0x3601, 0x33}, // analog control
+	{0x3602, 0x00}, // analog control
+	{0x3611, 0x0e}, // analog control
+	{0x3612, 0x2b}, // analog control
+	{0x3614, 0x50}, // analog control
+	{0x3620, 0x33}, // analog control
+	{0x3622, 0x00}, // analog control
+	{0x3630, 0xad}, // analog control
+	{0x3631, 0x00}, // analog control
+	{0x3632, 0x94}, // analog control
+	{0x3633, 0x17}, // analog control
+	{0x3634, 0x14}, // analog control
+	{0x3705, 0x2a}, // analog control
+	{0x3708, 0x66}, // analog control
+	{0x3709, 0x52}, // analog control
+	{0x370b, 0x23}, // analog control
+	{0x370c, 0xc3}, // analog control
+	{0x370d, 0x00}, // analog control
+	{0x370e, 0x00}, // analog control
+	{0x371c, 0x07}, // analog control
+	{0x3739, 0xd2}, // analog control
+	{0x373c, 0x00},
+
+	{0x3800, 0x00}, // xstart = 0
+	{0x3801, 0x00}, // xstart
+	{0x3802, 0x00}, // ystart = 0
+	{0x3803, 0x00}, // ystart
+	{0x3804, 0x0a}, // xend = 2623
+	{0x3805, 0x3f}, // yend
+	{0x3806, 0x07}, // yend = 1955
+	{0x3807, 0xa3}, // yend
+	{0x3808, 0x05}, // x output size = 1296
+	{0x3809, 0x10}, // x output size
+	{0x380a, 0x03}, // y output size = 972
+	{0x380b, 0xcc}, // y output size
+	{0x380c, 0x05}, // hts = 1408
+	{0x380d, 0x80}, // hts
+	{0x380e, 0x03}, // vts = 992
+	{0x380f, 0xe0}, // vts
+	{0x3810, 0x00}, // isp x win = 8
+	{0x3811, 0x08}, // isp x win
+	{0x3812, 0x00}, // isp y win = 4
+	{0x3813, 0x04}, // isp y win
+	{0x3814, 0x31}, // x inc
+	{0x3815, 0x31}, // y inc
+	{0x3817, 0x00}, // hsync start
+	{0x3820, 0x08}, // flip off, v bin off
+	{0x3821, 0x07}, // mirror on, h bin on
+	{0x3826, 0x03},
+	{0x3829, 0x00},
+	{0x382b, 0x0b},
+	{0x3830, 0x00},
+	{0x3836, 0x00},
+	{0x3837, 0x00},
+	{0x3838, 0x00},
+	{0x3839, 0x04},
+	{0x383a, 0x00},
+	{0x383b, 0x01},
+
+	{0x3b00, 0x00}, // strobe off
+	{0x3b02, 0x08}, // shutter delay
+	{0x3b03, 0x00}, // shutter delay
+	{0x3b04, 0x04}, // frex_exp
+	{0x3b05, 0x00}, // frex_exp
+	{0x3b06, 0x04},
+	{0x3b07, 0x08}, // frex inv
+	{0x3b08, 0x00}, // frex exp req
+	{0x3b09, 0x02}, // frex end option
+	{0x3b0a, 0x04}, // frex rst length
+	{0x3b0b, 0x00}, // frex strobe width
+	{0x3b0c, 0x3d}, // frex strobe width
+
+	{0x3f01, 0x0d},
+	{0x3f0f, 0xf5},
+
+	{0x4000, 0x89}, // blc enable
+	{0x4001, 0x02}, // blc start line
+	{0x4002, 0x45}, // blc auto, reset frame number = 5
+	{0x4004, 0x02}, // black line number
+	{0x4005, 0x18}, // blc normal freeze
+	{0x4006, 0x08},
+	{0x4007, 0x10},
+	{0x4008, 0x00},
+
+	{0x4300, 0xf8},
+	{0x4303, 0xff},
+	{0x4304, 0x00},
+	{0x4307, 0xff},
+	{0x4520, 0x00},
+	{0x4521, 0x00},
+	{0x4511, 0x22},
+
+	{0x481f, 0x3c}, // MIPI clk prepare min
+	{0x4826, 0x00}, // MIPI hs prepare min
+	{0x4837, 0x18}, // MIPI global timing
+	{0x4b00, 0x06},
+	{0x4b01, 0x0a},
+	{0x5000, 0xff}, // bpc on, wpc on
+	{0x5001, 0x00}, // awb disable
+	{0x5002, 0x41}, // win enable, awb gain enable
+	{0x5003, 0x0a}, // buf en, bin auto en
+	{0x5004, 0x00}, // size man off
+	{0x5043, 0x00},
+	{0x5013, 0x00},
+	{0x501f, 0x03}, // ISP output data
+	{0x503d, 0x00}, // test pattern off
+	{0x5180, 0x08}, // manual gain enable
+	{0x5a00, 0x08},
+	{0x5b00, 0x01},
+	{0x5b01, 0x40},
+	{0x5b02, 0x00},
+	{0x5b03, 0xf0},
+	{0x0100, 0x01}, // wake up from software sleep
+
+	{0x350b, 0x80}, // gain = 8x
+	{0x4837, 0x17}, // MIPI global timing
+};
+
+
+static struct msm_camera_i2c_conf_array ov5648_init_conf[] = {
+	{&ov5648_recommend_settings[0],
+	ARRAY_SIZE(ov5648_recommend_settings), 0, MSM_CAMERA_I2C_BYTE_DATA}
+};
+
+static struct msm_camera_i2c_conf_array ov5648_confs[] = {
+	{&ov5648_snap_settings[0],
+	ARRAY_SIZE(ov5648_snap_settings), 0, MSM_CAMERA_I2C_BYTE_DATA},
+	{&ov5648_prev_settings[0],
+	ARRAY_SIZE(ov5648_prev_settings), 0, MSM_CAMERA_I2C_BYTE_DATA},
+	{&ov5648_video_60fps_settings[0],
+	ARRAY_SIZE(ov5648_video_60fps_settings), 0, MSM_CAMERA_I2C_BYTE_DATA},
+	{&ov5648_video_90fps_settings[0],
+	ARRAY_SIZE(ov5648_video_90fps_settings), 0, MSM_CAMERA_I2C_BYTE_DATA},
+	{&ov5648_zsl_settings[0],
+	ARRAY_SIZE(ov5648_zsl_settings), 0, MSM_CAMERA_I2C_BYTE_DATA},
+};
+
+static struct msm_camera_csi_params ov5648_csi_params = {
+	.data_format = CSI_10BIT,
+	.lane_cnt    = 2,
+	.lane_assign = 0xe4,
+	.dpcm_scheme = 0,
+	.settle_cnt  = 10,
+};
+
+static struct v4l2_subdev_info ov5648_subdev_info[] = {
+	{
+		.code   = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt    = 1,
+		.order    = 0,
+	},
+	/* more can be supported, to be added later */
+};
+
+static struct msm_sensor_output_info_t ov5648_dimensions[] = {
+	{ /* For SNAPSHOT */
+		.x_output = 0xa20,         /*2592*/
+		.y_output = 0x798,         /*1944*/
+		.line_length_pclk = 0xb00,
+		.frame_length_lines = 0x7c0,
+		.vt_pixel_clk = 84000000,
+		.op_pixel_clk = 158000000,
+		.binning_factor = 0x0,
+	},
+	{ /* For PREVIEW */
+		.x_output = 0x510,         /*1296*/
+		.y_output = 0x3cc,         /*972*/
+		.line_length_pclk = 0xb00,
+		.frame_length_lines = 0x3e0,
+		.vt_pixel_clk = 84000000,
+		.op_pixel_clk = 110000000,
+		.binning_factor = 0x0,
+	},
+	{ /* For 60fps */
+		.x_output = 0x280,  /*640*/
+		.y_output = 0x1E0,   /*480*/
+		.line_length_pclk = 0x728,
+		.frame_length_lines = 0x1FC,
+		.vt_pixel_clk = 56000000,
+		.op_pixel_clk = 159408000,
+		.binning_factor = 0x0,
+	},
+	{ /* For 90fps */
+		.x_output = 0x280,  /*640*/
+		.y_output = 0x1E0,  /*480*/
+		.line_length_pclk = 0x728,
+		.frame_length_lines = 0x1FC,
+		.vt_pixel_clk = 84000000,
+		.op_pixel_clk = 159408000,
+		.binning_factor = 0x0,
+	},
+	{ /* For ZSL */
+		.x_output = 0xa20,         /*2592*/
+		.y_output = 0x798,         /*1944*/
+		.line_length_pclk = 0xb00,
+		.frame_length_lines = 0x7c0,
+		.vt_pixel_clk = 84000000,
+		.op_pixel_clk = 158000000,
+		.binning_factor = 0x0,
+	},
+
+};
+
+static struct msm_sensor_output_reg_addr_t ov5648_reg_addr = {
+	.x_output = 0x3808,
+	.y_output = 0x380A,
+	.line_length_pclk = 0x380C,
+	.frame_length_lines = 0x380E,
+};
+
+static struct msm_camera_csi_params *ov5648_csi_params_array[] = {
+	&ov5648_csi_params, /* Snapshot */
+	&ov5648_csi_params, /* Preview */
+	&ov5648_csi_params, /* 60fps */
+	&ov5648_csi_params, /* 90fps */
+	&ov5648_csi_params, /* ZSL */
+};
+
+static struct msm_sensor_id_info_t ov5648_id_info = {
+	.sensor_id_reg_addr = 0x300a,
+	.sensor_id = 0x5648,
+};
+
+static struct msm_sensor_exp_gain_info_t ov5648_exp_gain_info = {
+	.coarse_int_time_addr = 0x3500,
+	.global_gain_addr = 0x350A,
+	.vert_offset = 4,
+};
+
+void ov5648_sensor_reset_stream(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	msm_camera_i2c_write(
+		s_ctrl->sensor_i2c_client,
+		0x103, 0x1,
+		MSM_CAMERA_I2C_BYTE_DATA);
+}
+
+#ifdef OV5648_OTP_FEATURE
+
+int RG_Ratio_Typical = 0x128;
+int BG_Ratio_Typical = 0x180;
+
+struct otp_struct {
+     int customer_id;
+     int module_integrator_id;
+     int lens_id;
+     int rg_ratio;
+     int bg_ratio;
+     int user_data[2];
+     int light_rg;
+     int light_bg;
+};
+
+static struct msm_sensor_ctrl_t *otp_s_ctrl = NULL;
+
+int32_t ov5648_otp_write(uint16_t addr, uint16_t data)
+{
+	return msm_camera_i2c_write(otp_s_ctrl->sensor_i2c_client, addr, data,
+		MSM_CAMERA_I2C_BYTE_DATA);
+}
+
+
+uint16_t ov5648_otp_read(uint16_t addr)
+{
+    uint16_t temp;
+	msm_camera_i2c_read(otp_s_ctrl->sensor_i2c_client, addr, &temp,
+		MSM_CAMERA_I2C_BYTE_DATA);
+    return temp;
+}
+
+// index: index of otp group. (0, 1, 2)
+// return:    0, group index is empty
+//       1, group index has invalid data
+//       2, group index has valid data
+int ov5648_check_otp(int index)
+{
+     int temp, i;
+     int address;
+
+     if (index<2)
+     {
+         // read otp --Bank 0
+         ov5648_otp_write(0x3d84, 0xc0);
+         ov5648_otp_write(0x3d85, 0x00);
+         ov5648_otp_write(0x3d86, 0x0f);
+         ov5648_otp_write(0x3d81, 0x01);
+
+         usleep_range(10000, 10500);
+         address = 0x3d05 + index*9;
+     }
+     else{
+         // read otp --Bank 1
+         ov5648_otp_write(0x3d84, 0xc0);
+         ov5648_otp_write(0x3d85, 0x10);
+         ov5648_otp_write(0x3d86, 0x1f);
+         ov5648_otp_write(0x3d81, 0x01);
+         usleep_range(10000, 10500);
+         address = 0x3d05 + index*9-16;
+     }
+     temp = ov5648_otp_read(address);
+
+     // disable otp read
+     ov5648_otp_write(0x3d81, 0x00);
+
+     // clear otp buffer
+     for (i=0;i<16;i++) {
+         ov5648_otp_write(0x3d00 + i, 0x00);
+     }
+
+     if (!temp) {
+         return 0;
+     }
+     else if ((!(temp & 0x80)) && (temp&0x7f)) {
+         return 2;
+     }
+     else {
+         return 1;
+     }
+}
+
+// index: index of otp group. (0, 1, 2)
+// return:    0,
+int ov5648_read_otp(int index, struct otp_struct * otp_ptr)
+{
+     int i;
+     int address;
+
+     // read otp into buffer
+     if (index<2)
+     {
+         // read otp --Bank 0
+         ov5648_otp_write(0x3d84, 0xc0);
+         ov5648_otp_write(0x3d85, 0x00);
+         ov5648_otp_write(0x3d86, 0x0f);
+         ov5648_otp_write(0x3d81, 0x01);
+         usleep_range(10000, 10500);
+         address = 0x3d05 + index*9;
+     }
+     else{
+         // read otp --Bank 1
+         ov5648_otp_write(0x3d84, 0xc0);
+         ov5648_otp_write(0x3d85, 0x10);
+         ov5648_otp_write(0x3d86, 0x1f);
+         ov5648_otp_write(0x3d81, 0x01);
+         usleep_range(10000, 10500);
+         address = 0x3d05 + index*9-16;
+     }
+
+     (*otp_ptr).customer_id = (ov5648_otp_read(address) & 0x7f);
+     (*otp_ptr).module_integrator_id = ov5648_otp_read(address);
+     (*otp_ptr).lens_id = ov5648_otp_read(address + 1);
+     (*otp_ptr).rg_ratio = (ov5648_otp_read(address + 2)<<2) + (ov5648_otp_read(address + 6)>>6) ;
+     (*otp_ptr).bg_ratio = (ov5648_otp_read(address + 3)<<2) +((ov5648_otp_read(address + 6)>>4)&(0x03));
+     (*otp_ptr).user_data[0] = ov5648_otp_read(address + 4);
+     (*otp_ptr).user_data[1] = ov5648_otp_read(address + 5);
+     (*otp_ptr).light_rg = (int)(ov5648_otp_read(address + 7)<<2) + (int)((ov5648_otp_read(address + 6)>>2)&(0x03));
+     (*otp_ptr).light_bg = (int)(ov5648_otp_read(address + 8)<<2) + (int)((ov5648_otp_read(address + 6))&(0x03));
+
+     CDBG("==========OV5648 OTP INFO==========\r\n");
+     CDBG("%s-customer_id  = 0x%x\r\n", __func__, otp_ptr->customer_id);
+     CDBG("%s-module_integrator_id      = 0x%x\r\n", __func__, otp_ptr->module_integrator_id);
+     CDBG("%s-lens_id     = 0x%x\r\n", __func__, otp_ptr->lens_id);
+     CDBG("%s-rg_ratio     = 0x%x\r\n", __func__, otp_ptr->rg_ratio);
+     CDBG("%s-bg_ratio     = 0x%x\r\n", __func__, otp_ptr->bg_ratio);
+
+     CDBG("%s-user_data[0] = 0x%x\r\n", __func__, otp_ptr->user_data[0]);
+     CDBG("%s-user_data[1] = 0x%x\r\n", __func__, otp_ptr->user_data[1]);
+     CDBG("%s-light_rg = 0x%x\r\n", __func__, otp_ptr->light_rg);
+     CDBG("%s-light_bg = 0x%x\r\n", __func__, otp_ptr->light_bg);
+     // disable otp read
+     ov5648_otp_write(0x3d81, 0x00);
+
+     // clear otp buffer
+     for (i=0;i<16;i++) {
+         ov5648_otp_write(0x3d00 + i, 0x00);
+     }
+
+     return 0;
+}
+
+// R_gain, sensor red gain of AWB, 0x400 =1
+// G_gain, sensor green gain of AWB, 0x400 =1
+// B_gain, sensor blue gain of AWB, 0x400 =1
+// return 0;
+int ov5648_update_awb_gain(int R_gain, int G_gain, int B_gain)
+{
+     if (R_gain>0x400) {
+         ov5648_otp_write(0x5186, R_gain>>8);
+         ov5648_otp_write(0x5187, R_gain & 0x00ff);
+     }
+
+     if (G_gain>0x400) {
+         ov5648_otp_write(0x5188, G_gain>>8);
+         ov5648_otp_write(0x5189, G_gain & 0x00ff);
+     }
+
+     if (B_gain>0x400) {
+         ov5648_otp_write(0x518a, B_gain>>8);
+         ov5648_otp_write(0x518b, B_gain & 0x00ff);
+     }
+     return 0;
+}
+
+
+// call this function after OV5647 initialization
+// return value: 0 update success
+//       1, no OTP
+int ov5648_update_otp(struct msm_sensor_ctrl_t *s_ctrl)
+{
+     struct otp_struct current_otp;
+     int i;
+     int otp_index;
+     int temp;
+     int R_gain, G_gain, B_gain, G_gain_R, G_gain_B;
+     int rg,bg;
+     otp_s_ctrl = s_ctrl;
+
+
+     // R/G and B/G of current camera module is read out from sensor OTP
+     // check first OTP with valid data
+     for(i=0;i<3;i++) {
+         temp = ov5648_check_otp(i);
+         if (temp == 2) {
+              otp_index = i;
+              break;
+         }
+     }
+
+     if (i==3) {
+         // no valid wb OTP data
+         return 1;
+     }
+
+     ov5648_read_otp(otp_index, &current_otp);
+
+     if(current_otp.light_rg==0) {
+         // no light source information in OTP
+         rg = current_otp.rg_ratio;
+     }
+     else {
+         // light source information found in OTP
+         rg = current_otp.rg_ratio * (current_otp.light_rg +512) / 1024;
+     }
+
+     if(current_otp.light_bg==0) {
+         // no light source information in OTP
+         bg = current_otp.bg_ratio;
+     }
+     else {
+         // light source information found in OTP
+         bg = current_otp.bg_ratio * (current_otp.light_bg +512) / 1024;
+     }
+
+
+     //calculate G gain
+     //0x400 = 1x gain
+     if(bg < BG_Ratio_Typical) {
+         if (rg< RG_Ratio_Typical) {
+              // current_otp.bg_ratio < BG_Ratio_typical &&
+              // current_otp.rg_ratio < RG_Ratio_typical
+              G_gain = 0x400;
+              B_gain = 0x400 * BG_Ratio_Typical / bg;
+              R_gain = 0x400 * RG_Ratio_Typical / rg;
+         }
+         else {
+              // current_otp.bg_ratio < BG_Ratio_typical &&
+              // current_otp.rg_ratio >= RG_Ratio_typical
+              R_gain = 0x400;
+              G_gain = 0x400 * rg / RG_Ratio_Typical;
+              B_gain = G_gain * BG_Ratio_Typical /bg;
+         }
+     }
+     else {
+         if (rg < RG_Ratio_Typical) {
+              // current_otp.bg_ratio >= BG_Ratio_typical &&
+              // current_otp.rg_ratio < RG_Ratio_typical
+              B_gain = 0x400;
+              G_gain = 0x400 * bg / BG_Ratio_Typical;
+              R_gain = G_gain * RG_Ratio_Typical / rg;
+         }
+         else {
+              // current_otp.bg_ratio >= BG_Ratio_typical &&
+              // current_otp.rg_ratio >= RG_Ratio_typical
+              G_gain_B = 0x400 * bg / BG_Ratio_Typical;
+              G_gain_R = 0x400 * rg / RG_Ratio_Typical;
+
+              if(G_gain_B > G_gain_R ) {
+                  B_gain = 0x400;
+                  G_gain = G_gain_B;
+                  R_gain = G_gain * RG_Ratio_Typical /rg;
+              }
+              else {
+                   R_gain = 0x400;
+                   G_gain = G_gain_R;
+                   B_gain = G_gain * BG_Ratio_Typical / bg;
+              }
+         }
+     }
+
+     ov5648_update_awb_gain(R_gain, G_gain, B_gain);
+
+     return 0;
+
+}
+
+#endif
+
+static int32_t ov5648_write_pict_exp_gain(struct msm_sensor_ctrl_t *s_ctrl,
+		uint16_t gain, uint32_t line)
+{
+
+	static uint16_t max_line = 1964;
+	uint8_t gain_lsb, gain_hsb;
+	u8 intg_time_hsb, intg_time_msb, intg_time_lsb;
+
+	gain_lsb = (uint8_t) (gain);
+	gain_hsb = (uint8_t)((gain & 0x300)>>8);
+
+	CDBG(KERN_ERR "snapshot exposure seting 0x%x, 0x%x, %d"
+		, gain, line, line);
+	s_ctrl->func_tbl->sensor_group_hold_on(s_ctrl);
+	if (line > 1964) {
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+			s_ctrl->sensor_output_reg_addr->frame_length_lines,
+			(uint8_t)((line+4) >> 8),
+			MSM_CAMERA_I2C_BYTE_DATA);
+
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+			s_ctrl->sensor_output_reg_addr->frame_length_lines + 1,
+			(uint8_t)((line+4) & 0x00FF),
+			MSM_CAMERA_I2C_BYTE_DATA);
+		max_line = line + 4;
+	} else if (max_line > 1968) {
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+			s_ctrl->sensor_output_reg_addr->frame_length_lines,
+			(uint8_t)(1968 >> 8),
+			MSM_CAMERA_I2C_BYTE_DATA);
+
+		 msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+			s_ctrl->sensor_output_reg_addr->frame_length_lines + 1,
+			(uint8_t)(1968 & 0x00FF),
+			MSM_CAMERA_I2C_BYTE_DATA);
+			max_line = 1968;
+	}
+
+
+	line = line<<4;
+	/* ov5648 need this operation */
+	intg_time_hsb = (u8)(line>>16);
+	intg_time_msb = (u8) ((line & 0xFF00) >> 8);
+	intg_time_lsb = (u8) (line & 0x00FF);
+
+	/* FIXME for BLC trigger */
+	/* Coarse Integration Time */
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->coarse_int_time_addr,
+		intg_time_hsb,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->coarse_int_time_addr + 1,
+		intg_time_msb,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->coarse_int_time_addr + 2,
+		intg_time_lsb,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	/* gain */
+
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->global_gain_addr,
+		gain_hsb,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->global_gain_addr + 1,
+		gain_lsb^0x1,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	/* Coarse Integration Time */
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->coarse_int_time_addr,
+		intg_time_hsb,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->coarse_int_time_addr + 1,
+		intg_time_msb,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->coarse_int_time_addr + 2,
+		intg_time_lsb,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	/* gain */
+
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->global_gain_addr,
+		gain_hsb,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->global_gain_addr + 1,
+		gain_lsb,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+
+	s_ctrl->func_tbl->sensor_group_hold_off(s_ctrl);
+	return 0;
+
+}
+
+
+static int esposure_delay_en = 1;
+
+static int32_t ov5648_write_prev_exp_gain(struct msm_sensor_ctrl_t *s_ctrl,
+						uint16_t gain, uint32_t line)
+{
+	u8 intg_time_hsb, intg_time_msb, intg_time_lsb;
+	uint8_t gain_lsb, gain_hsb;
+	uint32_t fl_lines = s_ctrl->curr_frame_length_lines;
+	uint8_t offset = s_ctrl->sensor_exp_gain_info->vert_offset;
+
+	CDBG(KERN_ERR "preview exposure setting 0x%x, 0x%x, %d\n",
+		 gain, line, line);
+
+	gain_lsb = (uint8_t) (gain);
+	gain_hsb = (uint8_t)((gain & 0x300)>>8);
+
+	fl_lines = (fl_lines * s_ctrl->fps_divider) / Q10;
+
+	s_ctrl->func_tbl->sensor_group_hold_on(s_ctrl);
+
+	/* adjust frame rate */
+	if (line > (fl_lines - offset))
+		fl_lines = line + offset;
+
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_output_reg_addr->frame_length_lines,
+		(uint8_t)(fl_lines >> 8),
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_output_reg_addr->frame_length_lines + 1,
+		(uint8_t)(fl_lines & 0x00FF),
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	line = line<<4;
+	/* ov5648 need this operation */
+	intg_time_hsb = (u8)(line>>16);
+	intg_time_msb = (u8) ((line & 0xFF00) >> 8);
+	intg_time_lsb = (u8) (line & 0x00FF);
+
+
+	/* Coarse Integration Time */
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->coarse_int_time_addr,
+		intg_time_hsb,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->coarse_int_time_addr + 1,
+		intg_time_msb,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->coarse_int_time_addr + 2,
+		intg_time_lsb,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	/* gain */
+
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->global_gain_addr,
+		gain_hsb,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		s_ctrl->sensor_exp_gain_info->global_gain_addr + 1,
+		gain_lsb,
+		MSM_CAMERA_I2C_BYTE_DATA);
+
+	s_ctrl->func_tbl->sensor_group_hold_off(s_ctrl);
+
+	if(esposure_delay_en)
+	{
+		msleep(200);
+		esposure_delay_en = 0;
+	}
+	return 0;
+}
+
+static const struct i2c_device_id ov5648_i2c_id[] = {
+	{SENSOR_NAME, (kernel_ulong_t)&ov5648_s_ctrl},
+	{ }
+};
+extern void camera_af_software_powerdown(struct i2c_client *client);
+int32_t ov5648_sensor_i2c_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	int32_t rc = 0;
+	struct msm_sensor_ctrl_t *s_ctrl;
+
+	CDBG("%s IN\r\n", __func__);
+	s_ctrl = (struct msm_sensor_ctrl_t *)(id->driver_data);
+	s_ctrl->sensor_i2c_addr = s_ctrl->sensor_i2c_addr;
+
+	rc = msm_sensor_i2c_probe(client, id);
+
+	if (client->dev.platform_data == NULL) {
+		CDBG_HIGH("%s: NULL sensor data\n", __func__);
+		return -EFAULT;
+	}
+
+	/* send software powerdown cmd to AF motor, avoid current leak */
+	if(0 == rc)
+	{
+		camera_af_software_powerdown(client);
+	}
+	usleep_range(5000, 5100);
+
+	return rc;
+}
+
+static struct i2c_driver ov5648_i2c_driver = {
+	.id_table = ov5648_i2c_id,
+	.probe  = ov5648_sensor_i2c_probe,
+	.driver = {
+		.name = SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client ov5648_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static int __init msm_sensor_init_module(void)
+{
+	return i2c_add_driver(&ov5648_i2c_driver);
+}
+
+static struct v4l2_subdev_core_ops ov5648_subdev_core_ops = {
+	.ioctl = msm_sensor_subdev_ioctl,
+	.s_power = msm_sensor_power,
+};
+
+static struct v4l2_subdev_video_ops ov5648_subdev_video_ops = {
+	.enum_mbus_fmt = msm_sensor_v4l2_enum_fmt,
+};
+
+static struct v4l2_subdev_ops ov5648_subdev_ops = {
+	.core = &ov5648_subdev_core_ops,
+	.video  = &ov5648_subdev_video_ops,
+};
+
+int32_t ov5648_sensor_power_down(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	struct msm_camera_sensor_info *info = NULL;
+	unsigned short rdata;
+	int rc;
+	CDBG("%s IN\r\n", __func__);
+
+	info = s_ctrl->sensordata;
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		0x4202, 0xf,
+		MSM_CAMERA_I2C_BYTE_DATA);
+	msleep(40);
+	rc = msm_camera_i2c_read(s_ctrl->sensor_i2c_client, 0x3018,
+			&rdata, MSM_CAMERA_I2C_BYTE_DATA);
+	CDBG("ov5648_sensor_power_down: %d\n", rc);
+	rdata |= 0x18;
+	msm_camera_i2c_write(s_ctrl->sensor_i2c_client,
+		0x3018, rdata,
+		MSM_CAMERA_I2C_BYTE_DATA);
+	msleep(40);
+	gpio_direction_output(info->sensor_pwd, 0);
+	usleep_range(5000, 5100);
+	msm_sensor_power_down(s_ctrl);
+	msleep(40);
+	//if (s_ctrl->sensordata->pmic_gpio_enable){
+	//	lcd_camera_power_onoff(0);
+	//}
+	return 0;
+}
+
+int32_t ov5648_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	int32_t rc = 0;
+	struct msm_camera_sensor_info *info = s_ctrl->sensordata;
+	CDBG("%s IN\r\n", __func__);
+
+	CDBG("%s, sensor_pwd:%d, sensor_reset:%d\r\n",__func__, info->sensor_pwd, info->sensor_reset);
+
+	gpio_direction_output(info->sensor_pwd, 0);
+	gpio_direction_output(info->sensor_reset, 0);
+	usleep_range(5000, 6000);
+#if 0
+	for(rc = 0; rc<1000; rc++)
+	{
+		CDBG("GPIO cycle...\n");
+		gpio_direction_output(info->sensor_pwd, 1);
+		gpio_direction_output(info->sensor_reset, 0);
+		usleep_range(5000, 6000);
+		gpio_direction_output(info->sensor_pwd, 0);
+		gpio_direction_output(info->sensor_reset, 1);
+		usleep_range(5000, 6000);
+	}
+#endif
+	//if (info->pmic_gpio_enable) {
+	//	lcd_camera_power_onoff(1);
+	//}
+	usleep_range(5000, 6000);
+	rc = msm_sensor_power_up(s_ctrl);
+	if (rc < 0) {
+		CDBG("%s: msm_sensor_power_up failed\n", __func__);
+		return rc;
+	}
+
+	/* turn on ldo and vreg */
+	usleep_range(1000, 1100);
+	gpio_direction_output(info->sensor_pwd, 1);
+	msleep(10);
+	gpio_direction_output(info->sensor_reset, 1);
+	msleep(25);
+
+	return rc;
+
+}
+
+static int32_t vfe_clk = 266667000;
+static int is_first_preview = 1;
+int32_t ov5648_sensor_setting(struct msm_sensor_ctrl_t *s_ctrl,
+			int update_type, int res)
+{
+	int32_t rc = 0;
+	static int csi_config;
+	s_ctrl->func_tbl->sensor_stop_stream(s_ctrl);
+
+	if (update_type != MSM_SENSOR_REG_INIT)
+	{
+		if (csi_config == 0 || res == 0)
+			msleep(66);
+		else
+			msleep(266);
+
+		msm_camera_i2c_write(
+				s_ctrl->sensor_i2c_client,
+				0x4800, 0x25,
+				MSM_CAMERA_I2C_BYTE_DATA);
+	}
+	if (update_type == MSM_SENSOR_REG_INIT) {
+		CDBG("Register INIT\n");
+		s_ctrl->curr_csi_params = NULL;
+		msm_camera_i2c_write(
+				s_ctrl->sensor_i2c_client,
+				0x103, 0x1,
+				MSM_CAMERA_I2C_BYTE_DATA);
+		msm_sensor_enable_debugfs(s_ctrl);
+		msm_sensor_write_init_settings(s_ctrl);
+#ifdef OV5648_OTP_FEATURE
+		CDBG("Update OTP\n");
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client, 0x100, 0x1,
+				MSM_CAMERA_I2C_BYTE_DATA);
+		ov5648_update_otp(s_ctrl);
+		usleep_range(5000, 6000);
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client, 0x100, 0x0,
+		  MSM_CAMERA_I2C_BYTE_DATA);
+#endif
+		csi_config = 0;
+		is_first_preview = 1;
+	} else if (update_type == MSM_SENSOR_UPDATE_PERIODIC) {
+		CDBG("PERIODIC : %d\n", res);
+		msm_sensor_write_conf_array(
+			s_ctrl->sensor_i2c_client,
+			s_ctrl->msm_sensor_reg->mode_settings, res);
+		msleep(30);
+		if (!csi_config) {
+			s_ctrl->curr_csic_params = s_ctrl->csic_params[res];
+			CDBG("CSI config in progress\n");
+			v4l2_subdev_notify(&s_ctrl->sensor_v4l2_subdev,
+				NOTIFY_CSIC_CFG,
+				s_ctrl->curr_csic_params);
+			CDBG("CSI config is done\n");
+			mb();
+			msleep(30);
+			csi_config = 1;
+		msm_camera_i2c_write(
+			s_ctrl->sensor_i2c_client,
+			0x100, 0x1,
+			MSM_CAMERA_I2C_BYTE_DATA);
+		}
+		msm_camera_i2c_write(
+			s_ctrl->sensor_i2c_client,
+			0x4800, 0x4,
+			MSM_CAMERA_I2C_BYTE_DATA);
+
+		if(res == 1)
+		{
+			esposure_delay_en = 1;
+		}
+
+		if(!is_first_preview)
+		{
+			if(res == 0)
+			{
+				msleep(266);
+			}
+			else
+			{
+				msleep(66);
+			}
+		}
+		else
+		{
+			msleep(10);
+			is_first_preview = 0;
+		}
+		if (res == MSM_SENSOR_RES_4)
+			v4l2_subdev_notify(&s_ctrl->sensor_v4l2_subdev,
+					NOTIFY_PCLK_CHANGE,
+					&vfe_clk);
+		s_ctrl->func_tbl->sensor_start_stream(s_ctrl);
+		msleep(50);
+	}
+	return rc;
+}
+
+static struct msm_sensor_fn_t ov5648_func_tbl = {
+	.sensor_start_stream = msm_sensor_start_stream,
+	.sensor_stop_stream = msm_sensor_stop_stream,
+	.sensor_group_hold_on = msm_sensor_group_hold_on,
+	.sensor_group_hold_off = msm_sensor_group_hold_off,
+	.sensor_set_fps = msm_sensor_set_fps,
+	.sensor_write_exp_gain = ov5648_write_prev_exp_gain,
+	.sensor_write_snapshot_exp_gain = ov5648_write_pict_exp_gain,
+	.sensor_csi_setting = ov5648_sensor_setting,
+	.sensor_set_sensor_mode = msm_sensor_set_sensor_mode,
+	.sensor_mode_init = msm_sensor_mode_init,
+	.sensor_get_output_info = msm_sensor_get_output_info,
+	.sensor_config = msm_sensor_config,
+	.sensor_power_up = ov5648_sensor_power_up,
+	.sensor_power_down = ov5648_sensor_power_down,
+};
+
+static struct msm_sensor_reg_t ov5648_regs = {
+	.default_data_type = MSM_CAMERA_I2C_BYTE_DATA,
+	.start_stream_conf = ov5648_start_settings,
+	.start_stream_conf_size = ARRAY_SIZE(ov5648_start_settings),
+	.stop_stream_conf = ov5648_stop_settings,
+	.stop_stream_conf_size = ARRAY_SIZE(ov5648_stop_settings),
+	.group_hold_on_conf = ov5648_groupon_settings,
+	.group_hold_on_conf_size = ARRAY_SIZE(ov5648_groupon_settings),
+	.group_hold_off_conf = ov5648_groupoff_settings,
+	.group_hold_off_conf_size =
+		ARRAY_SIZE(ov5648_groupoff_settings),
+	.init_settings = &ov5648_init_conf[0],
+	.init_size = ARRAY_SIZE(ov5648_init_conf),
+	.mode_settings = &ov5648_confs[0],
+	.output_settings = &ov5648_dimensions[0],
+	.num_conf = ARRAY_SIZE(ov5648_confs),
+};
+
+static struct msm_sensor_ctrl_t ov5648_s_ctrl = {
+	.msm_sensor_reg = &ov5648_regs,
+	.sensor_i2c_client = &ov5648_sensor_i2c_client,
+	.sensor_i2c_addr =  0x36 << 1 ,
+	.sensor_output_reg_addr = &ov5648_reg_addr,
+	.sensor_id_info = &ov5648_id_info,
+	.sensor_exp_gain_info = &ov5648_exp_gain_info,
+	.cam_mode = MSM_SENSOR_MODE_INVALID,
+	.csic_params = &ov5648_csi_params_array[0],
+	.msm_sensor_mutex = &ov5648_mut,
+	.sensor_i2c_driver = &ov5648_i2c_driver,
+	.sensor_v4l2_subdev_info = ov5648_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(ov5648_subdev_info),
+	.sensor_v4l2_subdev_ops = &ov5648_subdev_ops,
+	.func_tbl = &ov5648_func_tbl,
+	.clk_rate = MSM_SENSOR_MCLK_24HZ,
+};
+
+module_init(msm_sensor_init_module);
+MODULE_DESCRIPTION("Omnivision WXGA Bayer sensor driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/video/msm/sensors/ov7695_v4l2.c b/drivers/media/video/msm/sensors/ov7695_v4l2.c
new file mode 100644
index 0000000..87c4e44
--- /dev/null
+++ b/drivers/media/video/msm/sensors/ov7695_v4l2.c
@@ -0,0 +1,948 @@
+/* Copyright (c) 2012, The Linux Foundation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "msm_sensor.h"
+#define SENSOR_NAME "ov7695"
+
+DEFINE_MUTEX(ov7695_mut);
+static struct msm_sensor_ctrl_t ov7695_s_ctrl;
+static int effect_value = CAMERA_EFFECT_OFF;
+static unsigned int SAT_U = 0x80; /* DEFAULT SATURATION VALUES*/
+static unsigned int SAT_V = 0x80; /* DEFAULT SATURATION VALUES*/
+
+static struct msm_camera_i2c_reg_conf ov7695_start_settings[] = {
+	{0x0100, 0x01},
+};
+
+static struct msm_camera_i2c_reg_conf ov7695_stop_settings[] = {
+	{0x0100, 0x00},
+};
+
+static struct msm_camera_i2c_reg_conf ov7695_recommend_settings[] = {
+	{0x0103, 0x01}, //software reset
+	{0x3620, 0x2f},
+	{0x3623, 0x12},
+	{0x3718, 0x88},
+	{0x3631, 0x44},
+	{0x3632, 0x05},
+	{0x3013, 0xd0},
+	{0x3705, 0x1d},
+	{0x3713, 0x0e},
+	{0x3012, 0x0a},
+	{0x3717, 0x19},
+	{0x0309, 0x24}, //DAC clk div by 4
+	{0x3820, 0x90},
+	{0x0101, 0x01}, //mirror on, flip off
+	{0x5100, 0x01}, //lenc
+	{0x520a, 0xf4}, //red gain from 0x400 to 0xfff
+	{0x520b, 0xf4}, //green gain from 0x400 to 0xfff
+	{0x520c, 0xf4}, //blue gain from 0x400 to 0xfff
+	{0x3a18, 0x01}, //gain ceiling 0x100
+	{0x3a19, 0x00}, //gain ceiling
+	{0x3503, 0x03}, //AGC manual on, AEC manual on
+	{0x3500, 0x00}, //exposure
+	{0x3501, 0x21}, //exposure
+	{0x3502, 0x00}, //exposure
+	{0x350a, 0x00}, //gain
+	{0x350b, 0x00}, //gain
+	{0x4008, 0x02}, //bl start
+	{0x4009, 0x09}, //bl end
+	{0x3002, 0x09}, //FSIN output
+	{0x3024, 0x00},
+	{0x3503, 0x00}, //AGC auto on, AEC auto on
+	//OV7695_ISP
+	{0x0101, 0x01}, //mirror_on
+	{0x5002, 0x40}, //[7:6] Y source select, manual 60Hz
+	{0x5910, 0x00}, //Y formula
+	{0x3a0f, 0x50}, //AEC in H
+	{0x3a10, 0x48}, //38 ;AEC in L
+	{0x3a1b, 0x50}, //40 ;AEC out H
+	{0x3a1e, 0x48}, //36 ;AEC out L
+	{0x3a11, 0x90}, //80 ;control zone H
+	{0x3a1f, 0x20}, //18 ;control zone L
+	{0x3a18, 0x00}, //gain ceiling
+	{0x3a19, 0xf8}, //gain ceiling, max gain 15.5x
+	{0x3503, 0x00}, //aec/agc auto on
+	{0x5000, 0xff}, //lcd, gma, awb, awbg, bc, wc, lenc, isp
+	{0x5001, 0x3f}, //avg, blc, sde, uv_avg, cmx, cip
+	//lens
+	{0x5100, 0x01},
+	{0x5101, 0xbf},
+	{0x5102, 0x00},
+	{0x5103, 0xaa},
+	{0x5104, 0x3f},
+	{0x5105, 0x05},
+	{0x5106, 0xff},
+	{0x5107, 0x0f},
+	{0x5108, 0x01},
+	{0x5109, 0xff},
+	{0x510a, 0x00},
+	{0x510b, 0x72},
+	{0x510c, 0x45},
+	{0x510d, 0x06},
+	{0x510e, 0xff},
+	{0x510f, 0x0f},
+	{0x5110, 0x01},
+	{0x5111, 0xfe},
+	{0x5112, 0x00},
+	{0x5113, 0x70},
+	{0x5114, 0x21},
+	{0x5115, 0x05},
+	{0x5116, 0xff},
+	{0x5117, 0x0f},
+	//AWB
+	{0x520a, 0x74}, //red gain from 0x400 to 0x7ff
+	{0x520b, 0x64}, //green gain from 0x400 to 0x7ff
+	{0x520c, 0xd4}, //blue gain from 0x400 to 0xdff
+	//Gamma
+	{0x5301, 0x07},
+	{0x5302, 0x0e},
+	{0x5303, 0x1d},
+	{0x5304, 0x3a},
+	{0x5305, 0x45},
+	{0x5306, 0x54},
+	{0x5307, 0x60},
+	{0x5308, 0x6c},
+	{0x5309, 0x7a},
+	{0x530a, 0x84},
+	{0x530b, 0x97},
+	{0x530c, 0xa9},
+	{0x530d, 0xc8},
+	{0x530e, 0xdc},
+	{0x530f, 0xef},
+	{0x5310, 0x16},
+	//sharpen/denoise
+	{0x5500, 0x08}, //sharp th1 8x
+	{0x5501, 0x48}, //sharp th2 8x
+	{0x5502, 0x12}, //sharp mt offset1
+	{0x5503, 0x03}, //sharp mt offset2
+	{0x5504, 0x08}, //dns th1 8x
+	{0x5505, 0x48}, //dns th2 8x
+	{0x5506, 0x02}, //dns offset1
+	{0x5507, 0x16}, //dns offset2
+	{0x5508, 0xad}, // //[6]:sharp_man [4]:dns_man
+	{0x5509, 0x08}, //sharpth th1 8x
+	{0x550a, 0x48}, //sharpth th2 8x
+	{0x550b, 0x06}, //sharpth offset1
+	{0x550c, 0x04}, //sharpth offset2
+	{0x550d, 0x01}, //recursive_en
+	//SDE, for saturation 120% under D65
+	{0x5800, 0x06}, //saturation on, contrast on
+	{0x5803, 0x2e}, //40 ; sat th2
+	{0x5804, 0x20}, //34 ; sat th1
+	{0x580b, 0x02}, //Y offset man on
+	//CMX QE
+	{0x5600, 0x00}, //mtx 1.7, UV CbCr disable
+	{0x5601, 0x2c}, //CMX1
+	{0x5602, 0x5a}, //CMX2
+	{0x5603, 0x06}, //CMX3
+	{0x5604, 0x1c}, //CMX4
+	{0x5605, 0x65}, //CMX5
+	{0x5606, 0x81}, //CMX6
+	{0x5607, 0x9f}, //CMX7
+	{0x5608, 0x8a}, //CMX8
+	{0x5609, 0x15}, //CMX9
+	{0x560a, 0x01}, //Sign
+	{0x560b, 0x9c}, //Sign
+	{0x3811, 0x07}, //Tradeoff position to make YUV/RAW x VGA/QVGA x Mirror/Flip all work
+	{0x3813, 0x06},
+	{0x3a05, 0xb0}, //banding filter 50hz
+	//MIPI
+	{0x4800, 0x20},
+	{0x4801, 0x0e},
+	{0x4802, 0x14},
+	{0x4803, 0x0a},
+	{0x4804, 0x0a},
+	{0x4805, 0x0a},
+	{0x4806, 0x30},
+	{0x4807, 0x05},
+	{0x0100, 0x01}, //streaming
+};
+
+static struct msm_camera_i2c_reg_conf ov7695_full_settings[] = {
+	{0x034c, 0x02},
+	{0x034d, 0x80},
+	{0x034e, 0x01},
+	{0x034f, 0xe0},
+	{0x0340, 0x02},
+	{0x0341, 0x18},
+	{0x0342, 0x02},
+	{0x0343, 0xea},
+};
+
+
+static struct v4l2_subdev_info ov7695_subdev_info[] = {
+	{
+		.code   = V4L2_MBUS_FMT_YUYV8_2X8,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt    = 1,
+		.order    = 0,
+	},
+	/* more can be supported, to be added later */
+};
+
+
+static struct msm_camera_i2c_conf_array ov7695_init_conf[] = {
+	{&ov7695_recommend_settings[0],
+	ARRAY_SIZE(ov7695_recommend_settings), 0, MSM_CAMERA_I2C_BYTE_DATA}
+};
+
+
+static struct msm_camera_i2c_conf_array ov7695_confs[] = {
+	{&ov7695_full_settings[0],
+	ARRAY_SIZE(ov7695_full_settings), 0, MSM_CAMERA_I2C_BYTE_DATA},
+};
+
+static struct msm_sensor_output_info_t ov7695_dimensions[] = {
+	{
+		.x_output = 0x280,
+		.y_output = 0x1E0,
+		.line_length_pclk = 0x2EA,
+		.frame_length_lines = 0x218,
+		.vt_pixel_clk = 12000000,
+		.op_pixel_clk = 9216000,
+		.binning_factor = 0,
+	},
+};
+
+static struct msm_camera_i2c_reg_conf ov7695_saturation[][6] = {
+	{{0x5604, 0x13}, {0x5605, 0x44},
+		{0x5606, 0x57}, {0x5607, 0x6c},
+		{0x5608, 0x5e}, {0x5609, 0x0e},},/* SATURATION LEVEL0*/
+	{{0x5604, 0x15}, {0x5605, 0x4b},
+		{0x5606, 0x60}, {0x5607, 0x76},
+		{0x5608, 0x67}, {0x5609, 0x0f},},/* SATURATION LEVEL1*/
+	{{0x5604, 0x17}, {0x5605, 0x53},
+		{0x5606, 0x6a}, {0x5607, 0x83},
+		{0x5608, 0x72}, {0x5609, 0x11},},/* SATURATION LEVEL2*/
+	{{0x5604, 0x19}, {0x5605, 0x5b},
+		{0x5606, 0x74}, {0x5607, 0x90},
+		{0x5608, 0x7d}, {0x5609, 0x13},},/* SATURATION LEVEL3*/
+	{{0x5604, 0x1c}, {0x5605, 0x65},
+		{0x5606, 0x81}, {0x5607, 0x9f},
+		{0x5608, 0x8a}, {0x5609, 0x15},},/* SATURATION LEVEL4*/
+	{{0x5604, 0x1e}, {0x5605, 0x6f},
+		{0x5606, 0x8d}, {0x5607, 0xae},
+		{0x5608, 0x97}, {0x5609, 0x17},},/* SATURATION LEVEL5*/
+	{{0x5604, 0x21}, {0x5605, 0x7a},
+		{0x5606, 0x9b}, {0x5607, 0xbf},
+		{0x5608, 0xa6}, {0x5609, 0x19},},/* SATURATION LEVEL6*/
+	{{0x5604, 0x25}, {0x5605, 0x86},
+		{0x5606, 0xab}, {0x5607, 0xd2},
+		{0x5608, 0xb7}, {0x5609, 0x1b},},/* SATURATION LEVEL7*/
+	{{0x5604, 0x28}, {0x5605, 0x93},
+		{0x5606, 0xbb}, {0x5607, 0xe8},
+		{0x5608, 0xca}, {0x5609, 0x1e},},/* SATURATION LEVEL8*/
+};
+
+static struct msm_camera_i2c_conf_array ov7695_saturation_confs[][1] = {
+	{{ov7695_saturation[0], ARRAY_SIZE(ov7695_saturation[0]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_saturation[1], ARRAY_SIZE(ov7695_saturation[1]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_saturation[2], ARRAY_SIZE(ov7695_saturation[2]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_saturation[3], ARRAY_SIZE(ov7695_saturation[3]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_saturation[4], ARRAY_SIZE(ov7695_saturation[4]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_saturation[5], ARRAY_SIZE(ov7695_saturation[5]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_saturation[6], ARRAY_SIZE(ov7695_saturation[6]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_saturation[7], ARRAY_SIZE(ov7695_saturation[7]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_saturation[8], ARRAY_SIZE(ov7695_saturation[8]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+};
+
+static int ov7695_saturation_enum_map[] = {
+	MSM_V4L2_SATURATION_L0,
+	MSM_V4L2_SATURATION_L1,
+	MSM_V4L2_SATURATION_L2,
+	MSM_V4L2_SATURATION_L3,
+	MSM_V4L2_SATURATION_L4,
+	MSM_V4L2_SATURATION_L5,
+	MSM_V4L2_SATURATION_L6,
+	MSM_V4L2_SATURATION_L7,
+	MSM_V4L2_SATURATION_L8,
+};
+
+static struct msm_camera_i2c_enum_conf_array ov7695_saturation_enum_confs = {
+	.conf = &ov7695_saturation_confs[0][0],
+	.conf_enum = ov7695_saturation_enum_map,
+	.num_enum = ARRAY_SIZE(ov7695_saturation_enum_map),
+	.num_index = ARRAY_SIZE(ov7695_saturation_confs),
+	.num_conf = ARRAY_SIZE(ov7695_saturation_confs[0]),
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+};
+
+static struct msm_camera_i2c_reg_conf ov7695_contrast[][4] = {
+	{{0x5001, 0x08, 0x00, 0x00, 0xf7}, {0x5808, 0x00, 0x00, 0x00, 0xfb},
+		{0x5805, 0x10, 0x00, 0x00, 0x00}, {0x5806, 0x10, 0x00, 0x00, 0x00},},	/* CONTRAST L0*/
+	{{0x5001, 0x08, 0x00, 0x00, 0xf7}, {0x5808, 0x00, 0x00, 0x00, 0xfb},
+		{0x5805, 0x14, 0x00, 0x00, 0x00}, {0x5806, 0x14, 0x00, 0x00, 0x00},},	/* CONTRAST L1*/
+	{{0x5001, 0x08, 0x00, 0x00, 0xf7}, {0x5808, 0x00, 0x00, 0x00, 0xfb},
+		{0x5805, 0x18, 0x00, 0x00, 0x00}, {0x5806, 0x18, 0x00, 0x00, 0x00},},	/* CONTRAST L2*/
+	{{0x5001, 0x08, 0x00, 0x00, 0xf7}, {0x5808, 0x00, 0x00, 0x00, 0xfb},
+		{0x5805, 0x1c, 0x00, 0x00, 0x00}, {0x5806, 0x1c, 0x00, 0x00, 0x00},},	/* CONTRAST L3*/
+	{{0x5001, 0x08, 0x00, 0x00, 0xf7}, {0x5808, 0x00, 0x00, 0x00, 0xfb},
+		{0x5805, 0x00, 0x00, 0x00, 0x00}, {0x5806, 0x20, 0x00, 0x00, 0x00},},	/* CONTRAST L4*/
+	{{0x5001, 0x08, 0x00, 0x00, 0xf7}, {0x5808, 0x00, 0x00, 0x00, 0xfb},
+		{0x5805, 0x10, 0x00, 0x00, 0x00}, {0x5806, 0x24, 0x00, 0x00, 0x00},},	/* CONTRAST L5*/
+	{{0x5001, 0x08, 0x00, 0x00, 0xf7}, {0x5808, 0x00, 0x00, 0x00, 0xfb},
+		{0x5805, 0x18, 0x00, 0x00, 0x00}, {0x5806, 0x28, 0x00, 0x00, 0x00},},	/* CONTRAST L6*/
+	{{0x5001, 0x08, 0x00, 0x00, 0xf7}, {0x5808, 0x00, 0x00, 0x00, 0xfb},
+		{0x5805, 0x1c, 0x00, 0x00, 0x00}, {0x5806, 0x2c, 0x00, 0x00, 0x00},},	/* CONTRAST L7*/
+	{{0x5001, 0x08, 0x00, 0x00, 0xf7}, {0x5808, 0x00, 0x00, 0x00, 0xfb},
+		{0x5805, 0x20, 0x00, 0x00, 0x00}, {0x5806, 0x30, 0x00, 0x00, 0x00},},	/* CONTRAST L8*/
+};
+
+static struct msm_camera_i2c_conf_array ov7695_contrast_confs[][1] = {
+	{{ov7695_contrast[0], ARRAY_SIZE(ov7695_contrast[0]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_contrast[1], ARRAY_SIZE(ov7695_contrast[1]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_contrast[2], ARRAY_SIZE(ov7695_contrast[2]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_contrast[3], ARRAY_SIZE(ov7695_contrast[3]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_contrast[4], ARRAY_SIZE(ov7695_contrast[4]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_contrast[5], ARRAY_SIZE(ov7695_contrast[5]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_contrast[6], ARRAY_SIZE(ov7695_contrast[6]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_contrast[7], ARRAY_SIZE(ov7695_contrast[7]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_contrast[8], ARRAY_SIZE(ov7695_contrast[8]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+};
+
+static int ov7695_contrast_enum_map[] = {
+	MSM_V4L2_CONTRAST_L0,
+	MSM_V4L2_CONTRAST_L1,
+	MSM_V4L2_CONTRAST_L2,
+	MSM_V4L2_CONTRAST_L3,
+	MSM_V4L2_CONTRAST_L4,
+	MSM_V4L2_CONTRAST_L5,
+	MSM_V4L2_CONTRAST_L6,
+	MSM_V4L2_CONTRAST_L7,
+	MSM_V4L2_CONTRAST_L8,
+};
+
+static struct msm_camera_i2c_enum_conf_array ov7695_contrast_enum_confs = {
+	.conf = &ov7695_contrast_confs[0][0],
+	.conf_enum = ov7695_contrast_enum_map,
+	.num_enum = ARRAY_SIZE(ov7695_contrast_enum_map),
+	.num_index = ARRAY_SIZE(ov7695_contrast_confs),
+	.num_conf = ARRAY_SIZE(ov7695_contrast_confs[0]),
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+};
+static struct msm_camera_i2c_reg_conf ov7695_sharpness[][2] = {
+	{{0x5508, 0x40, 0x00, 0x00, 0xBF}, {0x5502, 0x00, 0x00, 0x00, 0x00},},	/* SHARPNESS LEVEL 0*/
+	{{0x5508, 0x40, 0x00, 0x00, 0xBF}, {0x5502, 0x02, 0x00, 0x00, 0x00},},	/* SHARPNESS LEVEL 1*/
+	{{0x5508, 0x00, 0x00, 0x00, 0xBF}, {0x5508, 0x00, 0x00, 0x00, 0xbf},},	/* SHARPNESS LEVEL 2*/
+	{{0x5508, 0x40, 0x00, 0x00, 0xBF}, {0x5502, 0x04, 0x00, 0x00, 0x00},},	/* SHARPNESS LEVEL 3*/
+	{{0x5508, 0x40, 0x00, 0x00, 0xBF}, {0x5502, 0x0c, 0x00, 0x00, 0x00},},	/* SHARPNESS LEVEL 4*/
+	{{0x5508, 0x40, 0x00, 0x00, 0xBF}, {0x5502, 0x14, 0x00, 0x00, 0x00},},	/* SHARPNESS LEVEL 5*/
+	{{0x5508, 0x40, 0x00, 0x00, 0xBF}, {0x5502, 0x20, 0x00, 0x00, 0x00},},	/* SHARPNESS LEVEL 6*/
+};
+
+static struct msm_camera_i2c_conf_array ov7695_sharpness_confs[][1] = {
+	{{ov7695_sharpness[0], ARRAY_SIZE(ov7695_sharpness[0]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_sharpness[1], ARRAY_SIZE(ov7695_sharpness[1]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_sharpness[2], ARRAY_SIZE(ov7695_sharpness[2]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_sharpness[3], ARRAY_SIZE(ov7695_sharpness[3]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_sharpness[4], ARRAY_SIZE(ov7695_sharpness[4]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_sharpness[5], ARRAY_SIZE(ov7695_sharpness[5]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_sharpness[6], ARRAY_SIZE(ov7695_sharpness[6]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+};
+
+static int ov7695_sharpness_enum_map[] = {
+	MSM_V4L2_SHARPNESS_L0,
+	MSM_V4L2_SHARPNESS_L1,
+	MSM_V4L2_SHARPNESS_L2,
+	MSM_V4L2_SHARPNESS_L3,
+	MSM_V4L2_SHARPNESS_L4,
+	MSM_V4L2_SHARPNESS_L5,
+	MSM_V4L2_SHARPNESS_L6,
+};
+
+static struct msm_camera_i2c_enum_conf_array ov7695_sharpness_enum_confs = {
+	.conf = &ov7695_sharpness_confs[0][0],
+	.conf_enum = ov7695_sharpness_enum_map,
+	.num_enum = ARRAY_SIZE(ov7695_sharpness_enum_map),
+	.num_index = ARRAY_SIZE(ov7695_sharpness_confs),
+	.num_conf = ARRAY_SIZE(ov7695_sharpness_confs[0]),
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+};
+
+static struct msm_camera_i2c_reg_conf ov7695_exposure[][6] = {
+	{{0x3a0f, 0x38}, {0x3a10, 0x30}, {0x3a11, 0x61},
+		{0x3a1b, 0x38}, {0x3a1e, 0x30}, {0x3a1f, 0x10},},	/*EXPOSURECOMPENSATIONN2*/
+	{{0x3a0f, 0x48}, {0x3a10, 0x40}, {0x3a11, 0x80},
+		{0x3a1b, 0x48}, {0x3a1e, 0x40}, {0x3a1f, 0x20},},	/*EXPOSURECOMPENSATIONN1*/
+	{{0x3a0f, 0x58}, {0x3a10, 0x50}, {0x3a11, 0x91},
+		{0x3a1b, 0x58}, {0x3a1e, 0x50}, {0x3a1f, 0x20},},	/*EXPOSURECOMPENSATIOND*/
+	{{0x3a0f, 0x70}, {0x3a10, 0x60}, {0x3a11, 0xa0},
+		{0x3a1b, 0x70}, {0x3a1e, 0x60}, {0x3a1f, 0x20},},	/*EXPOSURECOMPENSATIONP1*/
+	{{0x3a0f, 0x80}, {0x3a10, 0x70}, {0x3a11, 0xa0},
+		{0x3a1b, 0x80}, {0x3a1e, 0x70}, {0x3a1f, 0x30},},	/*EXPOSURECOMPENSATIONP2*/
+};
+
+static struct msm_camera_i2c_conf_array ov7695_exposure_confs[][1] = {
+	{{ov7695_exposure[0], ARRAY_SIZE(ov7695_exposure[0]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_exposure[1], ARRAY_SIZE(ov7695_exposure[1]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_exposure[2], ARRAY_SIZE(ov7695_exposure[2]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_exposure[3], ARRAY_SIZE(ov7695_exposure[3]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_exposure[4], ARRAY_SIZE(ov7695_exposure[4]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+};
+
+static int ov7695_exposure_enum_map[] = {
+	MSM_V4L2_EXPOSURE_N2,
+	MSM_V4L2_EXPOSURE_N1,
+	MSM_V4L2_EXPOSURE_D,
+	MSM_V4L2_EXPOSURE_P1,
+	MSM_V4L2_EXPOSURE_P2,
+};
+
+static struct msm_camera_i2c_enum_conf_array ov7695_exposure_enum_confs = {
+	.conf = &ov7695_exposure_confs[0][0],
+	.conf_enum = ov7695_exposure_enum_map,
+	.num_enum = ARRAY_SIZE(ov7695_exposure_enum_map),
+	.num_index = ARRAY_SIZE(ov7695_exposure_confs),
+	.num_conf = ARRAY_SIZE(ov7695_exposure_confs[0]),
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+};
+
+static struct msm_camera_i2c_reg_conf ov7695_iso[][2] = {
+	{{0x3a18, 0x00}, {0x3a19, 0xf8},},   /*ISO_AUTO*/
+	{{0x3a18, 0x00}, {0x3a19, 0xf8},},   /*ISO_DEBLUR*/
+	{{0x3a18, 0x00}, {0x3a19, 0x3c},},   /*ISO_100*/
+	{{0x3a18, 0x00}, {0x3a19, 0x7c},},   /*ISO_200*/
+	{{0x3a18, 0x00}, {0x3a19, 0xc8},},   /*ISO_400*/
+	{{0x3a18, 0x00}, {0x3a19, 0xf8},},   /*ISO_800*/
+	{{0x3a18, 0x01}, {0x3a19, 0xf8},},   /*ISO_1600*/
+};
+
+
+static struct msm_camera_i2c_conf_array ov7695_iso_confs[][1] = {
+	{{ov7695_iso[0], ARRAY_SIZE(ov7695_iso[0]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_iso[1], ARRAY_SIZE(ov7695_iso[1]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_iso[2], ARRAY_SIZE(ov7695_iso[2]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_iso[3], ARRAY_SIZE(ov7695_iso[3]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_iso[4], ARRAY_SIZE(ov7695_iso[4]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_iso[5], ARRAY_SIZE(ov7695_iso[5]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+};
+
+static int ov7695_iso_enum_map[] = {
+	MSM_V4L2_ISO_AUTO ,
+	MSM_V4L2_ISO_DEBLUR,
+	MSM_V4L2_ISO_100,
+	MSM_V4L2_ISO_200,
+	MSM_V4L2_ISO_400,
+	MSM_V4L2_ISO_800,
+	MSM_V4L2_ISO_1600,
+};
+
+static struct msm_camera_i2c_enum_conf_array ov7695_iso_enum_confs = {
+	.conf = &ov7695_iso_confs[0][0],
+	.conf_enum = ov7695_iso_enum_map,
+	.num_enum = ARRAY_SIZE(ov7695_iso_enum_map),
+	.num_index = ARRAY_SIZE(ov7695_iso_confs),
+	.num_conf = ARRAY_SIZE(ov7695_iso_confs[0]),
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+};
+
+static struct msm_camera_i2c_reg_conf ov7695_special_effect[][4] = {
+	{{0x5001, 0x3f}, {0x5800, 0x06},
+		{0x5803, 0x00}, {0x5804, 0x18},},	/*for special effect OFF*/
+	{{0x5001, 0x04, 0x00, 0x00, 0xfb}, {0x5800, 0x58, 0x00, 0x00, 0xe7},
+		{0x5803, 0x80}, {0x5804, 0x80},},	/*for special effect MONO*/
+	{{0x5001, 0x04, 0x00, 0x00, 0xfb}, {0x5800, 0x40, 0x00, 0x00, 0xbf},
+		{0x5803, 0x00}, {0x5804, 0x18},},	/*for special efefct Negative*/
+	{{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},
+		{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},},/*Solarize is not supported by sensor*/
+	{{0x5001, 0x04, 0x00, 0x00, 0xfb}, {0x5800, 0x58, 0x00, 0x00, 0xe7},
+		{0x5803, 0x40}, {0x5804, 0xa0},},	/*for sepia*/
+	{{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},
+		{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},},/* Posteraize not supported */
+	{{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},
+		{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},},/* White board not supported*/
+	{{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},
+		{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},},/*Blackboard not supported*/
+	{{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},
+		{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},},/*Aqua not supported*/
+	{{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},
+		{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},},/*Emboss not supported */
+	{{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},
+		{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},},/*sketch not supported*/
+	{{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},
+		{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},},/*Neon not supported*/
+	{{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},
+		{-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1},},/*MAX value*/
+};
+
+static struct msm_camera_i2c_reg_conf ov7695_no_effect[] = {
+	{0x5001, 0x3f}, {0x5800, 0x06},
+	{0x5803, 0x00}, {0x5804, 0x18},
+};
+
+static struct msm_camera_i2c_conf_array ov7695_no_effect_confs[] = {
+	{&ov7695_no_effect[0],
+	ARRAY_SIZE(ov7695_no_effect), 0,
+	MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},
+};
+
+static struct msm_camera_i2c_conf_array ov7695_special_effect_confs[][1] = {
+	{{ov7695_special_effect[0],  ARRAY_SIZE(ov7695_special_effect[0]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_special_effect[1],  ARRAY_SIZE(ov7695_special_effect[1]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_special_effect[2],  ARRAY_SIZE(ov7695_special_effect[2]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_special_effect[3],  ARRAY_SIZE(ov7695_special_effect[3]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_special_effect[4],  ARRAY_SIZE(ov7695_special_effect[4]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_special_effect[5],  ARRAY_SIZE(ov7695_special_effect[5]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_special_effect[6],  ARRAY_SIZE(ov7695_special_effect[6]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_special_effect[7],  ARRAY_SIZE(ov7695_special_effect[7]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_special_effect[8],  ARRAY_SIZE(ov7695_special_effect[8]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_special_effect[9],  ARRAY_SIZE(ov7695_special_effect[9]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_special_effect[10], ARRAY_SIZE(ov7695_special_effect[10]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_special_effect[11], ARRAY_SIZE(ov7695_special_effect[11]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_special_effect[12], ARRAY_SIZE(ov7695_special_effect[12]), 0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+};
+
+static int ov7695_special_effect_enum_map[] = {
+	MSM_V4L2_EFFECT_OFF,
+	MSM_V4L2_EFFECT_MONO,
+	MSM_V4L2_EFFECT_NEGATIVE,
+	MSM_V4L2_EFFECT_SOLARIZE,
+	MSM_V4L2_EFFECT_SEPIA,
+	MSM_V4L2_EFFECT_POSTERAIZE,
+	MSM_V4L2_EFFECT_WHITEBOARD,
+	MSM_V4L2_EFFECT_BLACKBOARD,
+	MSM_V4L2_EFFECT_AQUA,
+	MSM_V4L2_EFFECT_EMBOSS,
+	MSM_V4L2_EFFECT_SKETCH,
+	MSM_V4L2_EFFECT_NEON,
+	MSM_V4L2_EFFECT_MAX,
+};
+
+static struct msm_camera_i2c_enum_conf_array
+		 ov7695_special_effect_enum_confs = {
+	.conf = &ov7695_special_effect_confs[0][0],
+	.conf_enum = ov7695_special_effect_enum_map,
+	.num_enum = ARRAY_SIZE(ov7695_special_effect_enum_map),
+	.num_index = ARRAY_SIZE(ov7695_special_effect_confs),
+	.num_conf = ARRAY_SIZE(ov7695_special_effect_confs[0]),
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+};
+
+static struct msm_camera_i2c_reg_conf ov7695_antibanding[][2] = {
+	{{0x3a00, 0x00, 0x00, 0x00, 0xdf},
+		{0x5002, 0x02, 0x00, 0x00, 0xfd},},   /*ANTIBANDING OFF*/
+	{{0x3a00, 0x20, 0x00, 0x00, 0xdf},
+		{0x5002, 0x00, 0x00, 0x00, 0xfd},},   /*ANTIBANDING 60HZ*/
+	{{0x3a00, 0x20, 0x00, 0x00, 0xdf},
+		{0x5002, 0x02, 0x00, 0x00, 0xfd},},   /*ANTIBANDING 50HZ*/
+	{{0x3a00, 0x20, 0x00, 0x00, 0xdf},
+		{0x5002, 0x02, 0x00, 0x00, 0xfd},},   /* ANTIBANDING AUTO*/
+};
+
+
+static struct msm_camera_i2c_conf_array ov7695_antibanding_confs[][1] = {
+	{{ov7695_antibanding[0], ARRAY_SIZE(ov7695_antibanding[0]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_antibanding[1], ARRAY_SIZE(ov7695_antibanding[1]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_antibanding[2], ARRAY_SIZE(ov7695_antibanding[2]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_antibanding[3], ARRAY_SIZE(ov7695_antibanding[3]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+};
+
+static int ov7695_antibanding_enum_map[] = {
+	MSM_V4L2_POWER_LINE_OFF,
+	MSM_V4L2_POWER_LINE_60HZ,
+	MSM_V4L2_POWER_LINE_50HZ,
+	MSM_V4L2_POWER_LINE_AUTO,
+};
+
+
+static struct msm_camera_i2c_enum_conf_array ov7695_antibanding_enum_confs = {
+	.conf = &ov7695_antibanding_confs[0][0],
+	.conf_enum = ov7695_antibanding_enum_map,
+	.num_enum = ARRAY_SIZE(ov7695_antibanding_enum_map),
+	.num_index = ARRAY_SIZE(ov7695_antibanding_confs),
+	.num_conf = ARRAY_SIZE(ov7695_antibanding_confs[0]),
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+};
+
+static struct msm_camera_i2c_reg_conf ov7695_wb_oem[][7] = {
+	{{0x5200, 0x20, 0x00, 0x00, 0xdf}, {0x5204, 0x04}, {0x5205, 0x00},
+		{0x5206, 0x04}, {0x5207, 0x00}, {0x5208, 0x04}, {0x5209, 0x00},},	/*WHITEBALNACE OFF*/
+	{{0x5200, 0x00, 0x00, 0x00, 0xdf}, {0x5204, 0x00}, {0x5205, 0x00},
+		{0x5206, 0x00}, {0x5207, 0x00}, {0x5208, 0x00}, {0x5209, 0x00},},	/*WHITEBALNACE AUTO*/
+	{{0x5200, 0x20, 0x00, 0x00, 0xdf}, {0x5204, 0x04}, {0x5205, 0x00},
+		{0x5206, 0x04}, {0x5207, 0xdc}, {0x5208, 0x0b}, {0x5209, 0xb4},},	/*WHITEBALNACE CUSTOM*/
+	{{0x5200, 0x20, 0x00, 0x00, 0xdf}, {0x5204, 0x05}, {0x5205, 0xa0},
+		{0x5206, 0x04}, {0x5207, 0x00}, {0x5208, 0x09}, {0x5209, 0xa0},},	/*INCANDISCENT*/
+	{{0x5200, 0x20, 0x00, 0x00, 0xdf}, {0x5204, 0x05}, {0x5205, 0xa0},
+		{0x5206, 0x04}, {0x5207, 0x00}, {0x5208, 0x08}, {0x5209, 0x4e},},	/*FLOURESECT*/
+	{{0x5200, 0x20, 0x00, 0x00, 0xdf}, {0x5204, 0x05}, {0x5205, 0x7b},
+		{0x5206, 0x04}, {0x5207, 0x00}, {0x5208, 0x05}, {0x5209, 0x15},},	/*DAYLIGHT*/
+	{{0x5200, 0x20, 0x00, 0x00, 0xdf}, {0x5204, 0x06}, {0x5205, 0x00},
+		{0x5206, 0x04}, {0x5207, 0x00}, {0x5208, 0x04}, {0x5209, 0x80},},	/*CLOUDY*/
+};
+
+static struct msm_camera_i2c_conf_array ov7695_wb_oem_confs[][1] = {
+	{{ov7695_wb_oem[0], ARRAY_SIZE(ov7695_wb_oem[0]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_wb_oem[1], ARRAY_SIZE(ov7695_wb_oem[1]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_wb_oem[2], ARRAY_SIZE(ov7695_wb_oem[2]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_wb_oem[3], ARRAY_SIZE(ov7695_wb_oem[3]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_wb_oem[4], ARRAY_SIZE(ov7695_wb_oem[4]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_wb_oem[5], ARRAY_SIZE(ov7695_wb_oem[5]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+	{{ov7695_wb_oem[6], ARRAY_SIZE(ov7695_wb_oem[6]),  0,
+		MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA},},
+};
+
+static int ov7695_wb_oem_enum_map[] = {
+	MSM_V4L2_WB_OFF,
+	MSM_V4L2_WB_AUTO ,
+	MSM_V4L2_WB_CUSTOM,
+	MSM_V4L2_WB_INCANDESCENT,
+	MSM_V4L2_WB_FLUORESCENT,
+	MSM_V4L2_WB_DAYLIGHT,
+	MSM_V4L2_WB_CLOUDY_DAYLIGHT,
+};
+
+static struct msm_camera_i2c_enum_conf_array ov7695_wb_oem_enum_confs = {
+	.conf = &ov7695_wb_oem_confs[0][0],
+	.conf_enum = ov7695_wb_oem_enum_map,
+	.num_enum = ARRAY_SIZE(ov7695_wb_oem_enum_map),
+	.num_index = ARRAY_SIZE(ov7695_wb_oem_confs),
+	.num_conf = ARRAY_SIZE(ov7695_wb_oem_confs[0]),
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+};
+
+
+int ov7695_saturation_msm_sensor_s_ctrl_by_enum(
+		struct msm_sensor_ctrl_t *s_ctrl,
+		struct msm_sensor_v4l2_ctrl_info_t *ctrl_info, int value)
+{
+	int rc = 0;
+	if (effect_value == CAMERA_EFFECT_OFF) {
+		rc = msm_sensor_write_enum_conf_array(
+			s_ctrl->sensor_i2c_client,
+			ctrl_info->enum_cfg_settings, value);
+	}
+	if (value <= MSM_V4L2_SATURATION_L8)
+		SAT_U = SAT_V = value * 0x10;
+	CDBG("--CAMERA-- %s ...(End)\n", __func__);
+	return rc;
+}
+
+
+int ov7695_contrast_msm_sensor_s_ctrl_by_enum(
+		struct msm_sensor_ctrl_t *s_ctrl,
+		struct msm_sensor_v4l2_ctrl_info_t *ctrl_info, int value)
+{
+	int rc = 0;
+	if (effect_value == CAMERA_EFFECT_OFF) {
+		rc = msm_sensor_write_enum_conf_array(
+			s_ctrl->sensor_i2c_client,
+			ctrl_info->enum_cfg_settings, value);
+	}
+	return rc;
+}
+
+int ov7695_sharpness_msm_sensor_s_ctrl_by_enum(
+		struct msm_sensor_ctrl_t *s_ctrl,
+		struct msm_sensor_v4l2_ctrl_info_t *ctrl_info, int value)
+{
+	int rc = 0;
+	if (effect_value == CAMERA_EFFECT_OFF) {
+		rc = msm_sensor_write_enum_conf_array(
+			s_ctrl->sensor_i2c_client,
+			ctrl_info->enum_cfg_settings, value);
+	}
+	return rc;
+}
+
+int ov7695_effect_msm_sensor_s_ctrl_by_enum(struct msm_sensor_ctrl_t *s_ctrl,
+		struct msm_sensor_v4l2_ctrl_info_t *ctrl_info, int value)
+{
+	int rc = 0;
+	effect_value = value;
+	if (effect_value == CAMERA_EFFECT_OFF) {
+		rc = msm_sensor_write_conf_array(
+			s_ctrl->sensor_i2c_client,
+			s_ctrl->msm_sensor_reg->no_effect_settings, 0);
+		if (rc < 0) {
+			CDBG("write faield\n");
+			return rc;
+		}
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client, 0xda, SAT_U,
+			MSM_CAMERA_I2C_BYTE_DATA);
+		msm_camera_i2c_write(s_ctrl->sensor_i2c_client, 0xdb, SAT_V,
+			MSM_CAMERA_I2C_BYTE_DATA);
+	} else {
+		rc = msm_sensor_write_enum_conf_array(
+			s_ctrl->sensor_i2c_client,
+			ctrl_info->enum_cfg_settings, value);
+	}
+	return rc;
+}
+
+int ov7695_antibanding_msm_sensor_s_ctrl_by_enum(
+		struct msm_sensor_ctrl_t *s_ctrl,
+		struct msm_sensor_v4l2_ctrl_info_t *ctrl_info, int value)
+{
+	int rc = 0;
+		return rc;
+}
+
+int ov7695_msm_sensor_s_ctrl_by_enum(struct msm_sensor_ctrl_t *s_ctrl,
+		struct msm_sensor_v4l2_ctrl_info_t *ctrl_info, int value)
+{
+	int rc = 0;
+	rc = msm_sensor_write_enum_conf_array(
+		s_ctrl->sensor_i2c_client,
+		ctrl_info->enum_cfg_settings, value);
+	if (rc < 0) {
+		CDBG("write faield\n");
+		return rc;
+	}
+	return rc;
+}
+
+struct msm_sensor_v4l2_ctrl_info_t ov7695_v4l2_ctrl_info[] = {
+	{
+		.ctrl_id = V4L2_CID_SATURATION,
+		.min = MSM_V4L2_SATURATION_L0,
+		.max = MSM_V4L2_SATURATION_L8,
+		.step = 1,
+		.enum_cfg_settings = &ov7695_saturation_enum_confs,
+		.s_v4l2_ctrl = ov7695_saturation_msm_sensor_s_ctrl_by_enum,
+	},
+	{
+		.ctrl_id = V4L2_CID_CONTRAST,
+		.min = MSM_V4L2_CONTRAST_L0,
+		.max = MSM_V4L2_CONTRAST_L8,
+		.step = 1,
+		.enum_cfg_settings = &ov7695_contrast_enum_confs,
+		.s_v4l2_ctrl = ov7695_contrast_msm_sensor_s_ctrl_by_enum,
+	},
+	{
+		.ctrl_id = V4L2_CID_SHARPNESS,
+		.min = MSM_V4L2_SHARPNESS_L0,
+		.max = MSM_V4L2_SHARPNESS_L6,
+		.step = 1,
+		.enum_cfg_settings = &ov7695_sharpness_enum_confs,
+		.s_v4l2_ctrl = ov7695_sharpness_msm_sensor_s_ctrl_by_enum,
+	},
+	{
+		.ctrl_id = V4L2_CID_EXPOSURE,
+		.min = MSM_V4L2_EXPOSURE_N2,
+		.max = MSM_V4L2_EXPOSURE_P2,
+		.step = 1,
+		.enum_cfg_settings = &ov7695_exposure_enum_confs,
+		.s_v4l2_ctrl = ov7695_msm_sensor_s_ctrl_by_enum,
+	},
+	{
+		.ctrl_id = MSM_V4L2_PID_ISO,
+		.min = MSM_V4L2_ISO_AUTO,
+		.max = MSM_V4L2_ISO_1600,
+		.step = 1,
+		.enum_cfg_settings = &ov7695_iso_enum_confs,
+		.s_v4l2_ctrl = ov7695_msm_sensor_s_ctrl_by_enum,
+	},
+	{
+		.ctrl_id = V4L2_CID_SPECIAL_EFFECT,
+		.min = MSM_V4L2_EFFECT_OFF,
+		.max = MSM_V4L2_EFFECT_SEPIA,
+		.step = 1,
+		.enum_cfg_settings = &ov7695_special_effect_enum_confs,
+		.s_v4l2_ctrl = ov7695_effect_msm_sensor_s_ctrl_by_enum,
+	},
+	{
+		.ctrl_id = V4L2_CID_POWER_LINE_FREQUENCY,
+		.min = MSM_V4L2_POWER_LINE_OFF,
+		.max = MSM_V4L2_POWER_LINE_AUTO,
+		.step = 1,
+		.enum_cfg_settings = &ov7695_antibanding_enum_confs,
+		.s_v4l2_ctrl = ov7695_antibanding_msm_sensor_s_ctrl_by_enum,
+	},
+	{
+		.ctrl_id = V4L2_CID_WHITE_BALANCE_TEMPERATURE,
+		.min = MSM_V4L2_WB_OFF,
+		.max = MSM_V4L2_WB_CLOUDY_DAYLIGHT,
+		.step = 1,
+		.enum_cfg_settings = &ov7695_wb_oem_enum_confs,
+		.s_v4l2_ctrl = ov7695_msm_sensor_s_ctrl_by_enum,
+	},
+
+};
+static struct msm_camera_csi_params ov7695_csi_params = {
+	.data_format = CSI_8BIT,
+	.lane_cnt    = 1,
+	.lane_assign = 0xe4,
+	.dpcm_scheme = 0,
+	.settle_cnt  = 0x19,
+};
+
+static struct msm_camera_csi_params *ov7695_csi_params_array[] = {
+	&ov7695_csi_params,
+};
+
+static struct msm_sensor_output_reg_addr_t ov7695_reg_addr = {
+	.x_output = 0x034C,
+	.y_output = 0x034E,
+	.line_length_pclk = 0x0342,
+	.frame_length_lines = 0x0340,
+};
+
+static struct msm_sensor_id_info_t ov7695_id_info = {
+	.sensor_id_reg_addr = 0x300A,
+	.sensor_id = 0x7695,
+};
+
+static const struct i2c_device_id ov7695_i2c_id[] = {
+	{SENSOR_NAME, (kernel_ulong_t)&ov7695_s_ctrl},
+	{ }
+};
+
+
+static struct i2c_driver ov7695_i2c_driver = {
+	.id_table = ov7695_i2c_id,
+	.probe  = msm_sensor_i2c_probe,
+	.driver = {
+		.name = SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client ov7695_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static int __init msm_sensor_init_module(void)
+{
+	int rc = 0;
+	CDBG("ov7695\n");
+
+	rc = i2c_add_driver(&ov7695_i2c_driver);
+
+	return rc;
+}
+
+static struct v4l2_subdev_core_ops ov7695_subdev_core_ops = {
+	.s_ctrl = msm_sensor_v4l2_s_ctrl,
+	.queryctrl = msm_sensor_v4l2_query_ctrl,
+	.ioctl = msm_sensor_subdev_ioctl,
+	.s_power = msm_sensor_power,
+};
+
+static struct v4l2_subdev_video_ops ov7695_subdev_video_ops = {
+	.enum_mbus_fmt = msm_sensor_v4l2_enum_fmt,
+};
+
+static struct v4l2_subdev_ops ov7695_subdev_ops = {
+	.core = &ov7695_subdev_core_ops,
+	.video  = &ov7695_subdev_video_ops,
+};
+
+static struct msm_sensor_fn_t ov7695_func_tbl = {
+	.sensor_start_stream = msm_sensor_start_stream,
+	.sensor_stop_stream = msm_sensor_stop_stream,
+	.sensor_csi_setting = msm_sensor_setting1,
+	.sensor_set_sensor_mode = msm_sensor_set_sensor_mode,
+	.sensor_mode_init = msm_sensor_mode_init,
+	.sensor_get_output_info = msm_sensor_get_output_info,
+	.sensor_config = msm_sensor_config,
+	.sensor_power_up = msm_sensor_power_up,
+	.sensor_power_down = msm_sensor_power_down,
+	.sensor_get_csi_params = msm_sensor_get_csi_params,
+};
+
+static struct msm_sensor_reg_t ov7695_regs = {
+	.default_data_type = MSM_CAMERA_I2C_BYTE_DATA,
+	.start_stream_conf = ov7695_start_settings,
+	.start_stream_conf_size = ARRAY_SIZE(ov7695_start_settings),
+	.stop_stream_conf = ov7695_stop_settings,
+	.stop_stream_conf_size = ARRAY_SIZE(ov7695_stop_settings),
+	.init_settings = &ov7695_init_conf[0],
+	.init_size = ARRAY_SIZE(ov7695_init_conf),
+	.mode_settings = &ov7695_confs[0],
+	.no_effect_settings = &ov7695_no_effect_confs[0],
+	.output_settings = &ov7695_dimensions[0],
+	.num_conf = ARRAY_SIZE(ov7695_confs),
+};
+
+static struct msm_sensor_ctrl_t ov7695_s_ctrl = {
+	.msm_sensor_reg = &ov7695_regs,
+	.msm_sensor_v4l2_ctrl_info = ov7695_v4l2_ctrl_info,
+	.num_v4l2_ctrl = ARRAY_SIZE(ov7695_v4l2_ctrl_info),
+	.sensor_i2c_client = &ov7695_sensor_i2c_client,
+	.sensor_i2c_addr = 0x42,
+	.sensor_output_reg_addr = &ov7695_reg_addr,
+	.sensor_id_info = &ov7695_id_info,
+	.cam_mode = MSM_SENSOR_MODE_INVALID,
+	.csic_params = &ov7695_csi_params_array[0],
+	.msm_sensor_mutex = &ov7695_mut,
+	.sensor_i2c_driver = &ov7695_i2c_driver,
+	.sensor_v4l2_subdev_info = ov7695_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(ov7695_subdev_info),
+	.sensor_v4l2_subdev_ops = &ov7695_subdev_ops,
+	.func_tbl = &ov7695_func_tbl,
+	.clk_rate = MSM_SENSOR_MCLK_24HZ,
+};
+
+module_init(msm_sensor_init_module);
+MODULE_DESCRIPTION("Omnivision VGA YUV sensor driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/media/msm_camera.h b/include/media/msm_camera.h
index af77572..3134975 100644
--- a/include/media/msm_camera.h
+++ b/include/media/msm_camera.h
@@ -1318,6 +1318,7 @@ enum msm_actuator_addr_type {
 enum msm_actuator_write_type {
 	MSM_ACTUATOR_WRITE_HW_DAMP,
 	MSM_ACTUATOR_WRITE_DAC,
+	MSM_ACTUATOR_WRITE_DAC_AD5823,
 };
 
 struct msm_actuator_reg_params_t {
@@ -1396,6 +1397,8 @@ enum af_camera_name {
 	ACTUATOR_MAIN_CAM_3,
 	ACTUATOR_MAIN_CAM_4,
 	ACTUATOR_MAIN_CAM_5,
+	ACTUATOR_MAIN_CAM_6,
+	ACTUATOR_MAIN_CAM_7,
 	ACTUATOR_WEB_CAM_0,
 	ACTUATOR_WEB_CAM_1,
 	ACTUATOR_WEB_CAM_2,
-- 
1.7.0.4

